   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"modes51.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  18              	register_handler:
  19              	.LFB0:
  20              		.file 1 "modes51.c"
   1:modes51.c     **** #include "config.h"
   2:modes51.c     **** #include "hardware.h"
   3:modes51.c     **** #include "modes.h"
   4:modes51.c     **** #include "module.h"
   5:modes51.c     **** #include "registers.h"
   6:modes51.c     **** #include "robot.h"
   7:modes51.c     **** 
   8:modes51.c     **** const float FREQ = 1.0;        // Hz
   9:modes51.c     **** const uint8_t MOTOR_ADDR = 21; // Motor address
  10:modes51.c     **** 
  11:modes51.c     **** static int8_t register_handler(uint8_t operation, uint8_t address,
  12:modes51.c     ****                                RadioData *radio_data) {
  21              		.loc 1 12 0
  22              		.cfi_startproc
  23              		@ Function supports interworking.
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
  13:modes51.c     **** 
  14:modes51.c     ****   switch (operation) {
  28              		.loc 1 14 0
  29 0000 000050E3 		cmp	r0, #0
  30              	.LVL1:
  31 0004 0200000A 		beq	.L3
  32 0008 040050E3 		cmp	r0, #4
  33 000c 0900001A 		bne	.L6
  34 0010 030000EA 		b	.L4
  35              	.L3:
  15:modes51.c     ****   case ROP_READ_8:
  16:modes51.c     ****     radio_data->byte = reg8_table[address];
  36              		.loc 1 16 0
  37 0014 24309FE5 		ldr	r3, .L8
  38 0018 0130D3E7 		ldrb	r3, [r3, r1]	@ zero_extendqisi2
  39 001c 0030C2E5 		strb	r3, [r2, #0]
  40 0020 020000EA 		b	.L7
  41              	.L4:
  17:modes51.c     ****     return TRUE;
  18:modes51.c     ****   case ROP_WRITE_8:
  19:modes51.c     ****     reg8_table[address] = radio_data->byte; // Allow writing to register
  42              		.loc 1 19 0
  43 0024 0020D2E5 		ldrb	r2, [r2, #0]	@ zero_extendqisi2
  44              	.LVL2:
  45 0028 10309FE5 		ldr	r3, .L8
  46 002c 0120C3E7 		strb	r2, [r3, r1]
  47              	.L7:
  20:modes51.c     ****     return TRUE;
  48              		.loc 1 20 0
  49 0030 0100A0E3 		mov	r0, #1
  50 0034 1EFF2FE1 		bx	lr
  51              	.LVL3:
  52              	.L6:
  21:modes51.c     ****   }
  22:modes51.c     ****   return FALSE;
  53              		.loc 1 22 0
  54 0038 0000A0E3 		mov	r0, #0
  23:modes51.c     **** }
  55              		.loc 1 23 0
  56 003c 1EFF2FE1 		bx	lr
  57              	.L9:
  58              		.align	2
  59              	.L8:
  60 0040 00000000 		.word	reg8_table
  61              		.cfi_endproc
  62              	.LFE0:
  64              		.global	__aeabi_ui2f
  65              		.global	__aeabi_fdiv
  66              		.global	__aeabi_fadd
  67              		.global	__aeabi_f2d
  68              		.global	__aeabi_dmul
  69              		.global	__aeabi_d2f
  70              		.global	__aeabi_fmul
  71              		.global	__aeabi_f2iz
  72              		.global	__aeabi_fcmpge
  73              		.global	__aeabi_f2uiz
  74              		.align	2
  75              		.global	sine_demo_mode
  77              	sine_demo_mode:
  78              	.LFB1:
  24:modes51.c     **** 
  25:modes51.c     **** void sine_demo_mode() {
  79              		.loc 1 25 0
  80              		.cfi_startproc
  81              		@ Function supports interworking.
  82              		@ args = 0, pretend = 0, frame = 0
  83              		@ frame_needed = 0, uses_anonymous_args = 0
  84 0044 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
  85              	.LCFI0:
  86              		.cfi_def_cfa_offset 16
  87              		.cfi_offset 4, -16
  88              		.cfi_offset 5, -12
  89              		.cfi_offset 6, -8
  90              		.cfi_offset 14, -4
  26:modes51.c     ****   uint32_t dt, cycletimer;
  27:modes51.c     ****   float my_time, delta_t, angle;
  28:modes51.c     ****   int8_t angle_rounded;
  29:modes51.c     **** 
  30:modes51.c     ****   // Initialize and start the motor's PID controller
  31:modes51.c     ****   init_body_module(MOTOR_ADDR);
  91              		.loc 1 31 0
  92 0048 1500A0E3 		mov	r0, #21
  93 004c FEFFFFEB 		bl	init_body_module
  94              	.LVL4:
  32:modes51.c     ****   start_pid(MOTOR_ADDR);
  95              		.loc 1 32 0
  96 0050 1500A0E3 		mov	r0, #21
  97 0054 FEFFFFEB 		bl	start_pid
  98              	.LVL5:
  33:modes51.c     ****   set_color(4); // Set LED to red to indicate motor is active
  99              		.loc 1 33 0
 100 0058 0400A0E3 		mov	r0, #4
 101 005c FEFFFFEB 		bl	set_color
 102              	.LVL6:
  34:modes51.c     **** 
  35:modes51.c     ****   cycletimer = getSysTICs();
 103              		.loc 1 35 0
 104 0060 FEFFFFEB 		bl	getSysTICs
 105              	.LVL7:
  36:modes51.c     ****   my_time = 0;
 106              		.loc 1 36 0
 107 0064 0060A0E3 		mov	r6, #0
  35:modes51.c     ****   cycletimer = getSysTICs();
 108              		.loc 1 35 0
 109 0068 0050A0E1 		mov	r5, r0
 110              	.LVL8:
 111              	.L14:
  37:modes51.c     **** 
  38:modes51.c     ****   do {
  39:modes51.c     ****     // Calculates the delta_t in seconds and adds it to the current time
  40:modes51.c     ****     dt = getElapsedSysTICs(cycletimer);
 112              		.loc 1 40 0
 113 006c 0500A0E1 		mov	r0, r5
 114 0070 FEFFFFEB 		bl	getElapsedSysTICs
 115              	.LVL9:
 116 0074 0040A0E1 		mov	r4, r0
 117              	.LVL10:
  41:modes51.c     ****     cycletimer = getSysTICs();
 118              		.loc 1 41 0
 119 0078 FEFFFFEB 		bl	getSysTICs
 120              	.LVL11:
 121 007c 0050A0E1 		mov	r5, r0
 122              	.LVL12:
  42:modes51.c     ****     delta_t = (float)dt / sysTICSperSEC;
 123              		.loc 1 42 0
 124 0080 0400A0E1 		mov	r0, r4
 125              	.LVL13:
 126 0084 FEFFFFEB 		bl	__aeabi_ui2f
 127              	.LVL14:
 128 0088 04119FE5 		ldr	r1, .L22
 129 008c FEFFFFEB 		bl	__aeabi_fdiv
 130              	.LVL15:
 131 0090 0010A0E1 		mov	r1, r0
  43:modes51.c     ****     my_time += delta_t;
 132              		.loc 1 43 0
 133 0094 0600A0E1 		mov	r0, r6
 134 0098 FEFFFFEB 		bl	__aeabi_fadd
 135              	.LVL16:
 136 009c 0060A0E1 		mov	r6, r0
 137              	.LVL17:
  44:modes51.c     **** 
  45:modes51.c     ****     // Calculates the sine wave for motor angle (Â±40 degrees)
  46:modes51.c     ****     angle = 40.0 * sin(M_TWOPI * FREQ * my_time);
 138              		.loc 1 46 0
 139 00a0 FEFFFFEB 		bl	__aeabi_f2d
 140              	.LVL18:
 141 00a4 EC209FE5 		ldr	r2, .L22+4
 142 00a8 EC309FE5 		ldr	r3, .L22+8
 143 00ac FEFFFFEB 		bl	__aeabi_dmul
 144              	.LVL19:
 145 00b0 FEFFFFEB 		bl	sin
 146              	.LVL20:
 147 00b4 E4309FE5 		ldr	r3, .L22+12
 148 00b8 0020A0E3 		mov	r2, #0
 149 00bc FEFFFFEB 		bl	__aeabi_dmul
 150              	.LVL21:
 151 00c0 FEFFFFEB 		bl	__aeabi_d2f
 152              	.LVL22:
  47:modes51.c     **** 
  48:modes51.c     ****     // Convert angle to motor units
  49:modes51.c     ****     angle_rounded = DEG_TO_OUTPUT_BODY(angle);
 153              		.loc 1 49 0
 154 00c4 FF15A0E3 		mov	r1, #1069547520
  46:modes51.c     ****     angle = 40.0 * sin(M_TWOPI * FREQ * my_time);
 155              		.loc 1 46 0
 156 00c8 0040A0E1 		mov	r4, r0
 157              	.LVL23:
 158              		.loc 1 49 0
 159 00cc FEFFFFEB 		bl	__aeabi_fmul
 160              	.LVL24:
 161 00d0 FEFFFFEB 		bl	__aeabi_f2iz
 162              	.LVL25:
  50:modes51.c     **** 
  51:modes51.c     ****     // Send the angle to the motor
  52:modes51.c     ****     bus_set(MOTOR_ADDR, MREG_SETPOINT, angle_rounded);
 163              		.loc 1 52 0
 164 00d4 2F10A0E3 		mov	r1, #47
 165 00d8 FF2000E2 		and	r2, r0, #255
 166 00dc 1500A0E3 		mov	r0, #21
 167 00e0 FEFFFFEB 		bl	bus_set
 168              	.LVL26:
  53:modes51.c     **** 
  54:modes51.c     ****     // Also update LED for visual feedback (similar to original)
  55:modes51.c     ****     if (angle >= 0) {
 169              		.loc 1 55 0
 170 00e4 0400A0E1 		mov	r0, r4
 171 00e8 0010A0E3 		mov	r1, #0
 172 00ec FEFFFFEB 		bl	__aeabi_fcmpge
 173              	.LVL27:
 174 00f0 000050E3 		cmp	r0, #0
 175 00f4 0800000A 		beq	.L20
  56:modes51.c     ****       set_rgb(0, angle / 2 + 20, 32); // Brighter green as angle increases
 176              		.loc 1 56 0
 177 00f8 3F14A0E3 		mov	r1, #1056964608
 178 00fc 0400A0E1 		mov	r0, r4
 179 0100 FEFFFFEB 		bl	__aeabi_fmul
 180              	.LVL28:
 181 0104 98109FE5 		ldr	r1, .L22+16
 182 0108 FEFFFFEB 		bl	__aeabi_fadd
 183              	.LVL29:
 184 010c FEFFFFEB 		bl	__aeabi_f2uiz
 185              	.LVL30:
 186 0110 FF1000E2 		and	r1, r0, #255
 187 0114 0000A0E3 		mov	r0, #0
 188 0118 070000EA 		b	.L21
 189              	.L20:
  57:modes51.c     ****     } else {
  58:modes51.c     ****       set_rgb(-angle / 2 + 20, 0, 32); // Brighter red as angle decreases
 190              		.loc 1 58 0
 191 011c 3F14A0E3 		mov	r1, #1056964608
 192 0120 020184E2 		add	r0, r4, #-2147483648
 193 0124 FEFFFFEB 		bl	__aeabi_fmul
 194              	.LVL31:
 195 0128 74109FE5 		ldr	r1, .L22+16
 196 012c FEFFFFEB 		bl	__aeabi_fadd
 197              	.LVL32:
 198 0130 FEFFFFEB 		bl	__aeabi_f2uiz
 199              	.LVL33:
 200 0134 0010A0E3 		mov	r1, #0
 201 0138 FF0000E2 		and	r0, r0, #255
 202              	.L21:
 203 013c 2020A0E3 		mov	r2, #32
 204 0140 FEFFFFEB 		bl	set_rgb
 205              	.LVL34:
  59:modes51.c     ****     }
  60:modes51.c     **** 
  61:modes51.c     ****     // Make sure there is some delay, so that the timer output is not zero
  62:modes51.c     ****     pause(ONE_MS);
 206              		.loc 1 62 0
 207 0144 5C009FE5 		ldr	r0, .L22+20
 208 0148 FEFFFFEB 		bl	pause
 209              	.LVL35:
  63:modes51.c     **** 
  64:modes51.c     ****   } while (reg8_table[REG8_MODE] == IMODE_SINE_DEMO);
 210              		.loc 1 64 0
 211 014c 58309FE5 		ldr	r3, .L22+24
 212 0150 0030D3E5 		ldrb	r3, [r3, #0]	@ zero_extendqisi2
 213 0154 020053E3 		cmp	r3, #2
 214 0158 C3FFFF0A 		beq	.L14
  65:modes51.c     **** 
  66:modes51.c     ****   // Clean up: set motor to zero position
  67:modes51.c     ****   bus_set(MOTOR_ADDR, MREG_SETPOINT, 0);
 215              		.loc 1 67 0
 216 015c 2F10A0E3 		mov	r1, #47
 217 0160 0020A0E3 		mov	r2, #0
 218 0164 1500A0E3 		mov	r0, #21
 219 0168 FEFFFFEB 		bl	bus_set
 220              	.LVL36:
  68:modes51.c     ****   pause(ONE_SEC); // Let motor return to center
 221              		.loc 1 68 0
 222 016c 3C009FE5 		ldr	r0, .L22+28
 223 0170 FEFFFFEB 		bl	pause
 224              	.LVL37:
  69:modes51.c     **** 
  70:modes51.c     ****   // Stop the motor
  71:modes51.c     ****   bus_set(MOTOR_ADDR, MREG_MODE, MODE_IDLE);
 225              		.loc 1 71 0
 226 0174 1500A0E3 		mov	r0, #21
 227 0178 2810A0E3 		mov	r1, #40
 228 017c 0020A0E3 		mov	r2, #0
 229 0180 FEFFFFEB 		bl	bus_set
 230              	.LVL38:
  72:modes51.c     **** 
  73:modes51.c     ****   // Back to the "normal" green
  74:modes51.c     ****   set_color(1);
 231              		.loc 1 74 0
 232 0184 0100A0E3 		mov	r0, #1
 233 0188 FEFFFFEB 		bl	set_color
 234              	.LVL39:
  75:modes51.c     **** }
 235              		.loc 1 75 0
 236 018c 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 237 0190 1EFF2FE1 		bx	lr
 238              	.L23:
 239              		.align	2
 240              	.L22:
 241 0194 8096184B 		.word	1259902592
 242 0198 182D4454 		.word	1413754136
 243 019c FB211940 		.word	1075388923
 244 01a0 00004440 		.word	1078198272
 245 01a4 0000A041 		.word	1101004800
 246 01a8 10270000 		.word	10000
 247 01ac 00000000 		.word	reg8_table
 248 01b0 80969800 		.word	10000000
 249              		.cfi_endproc
 250              	.LFE1:
 252              		.align	2
 253              		.global	main_mode_loop
 255              	main_mode_loop:
 256              	.LFB2:
  76:modes51.c     **** 
  77:modes51.c     **** void main_mode_loop() {
 257              		.loc 1 77 0
 258              		.cfi_startproc
 259              		@ Function supports interworking.
 260              		@ args = 0, pretend = 0, frame = 0
 261              		@ frame_needed = 0, uses_anonymous_args = 0
 262 01b4 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 263              	.LCFI1:
 264              		.cfi_def_cfa_offset 16
 265              		.cfi_offset 3, -16
 266              		.cfi_offset 4, -12
 267              		.cfi_offset 5, -8
 268              		.cfi_offset 14, -4
  78:modes51.c     ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 269              		.loc 1 78 0
 270 01b8 2C509FE5 		ldr	r5, .L37
 271 01bc 0040A0E3 		mov	r4, #0
  79:modes51.c     ****   radio_add_reg_callback(register_handler);
 272              		.loc 1 79 0
 273 01c0 28009FE5 		ldr	r0, .L37+4
  78:modes51.c     ****   reg8_table[REG8_MODE] = IMODE_IDLE;
 274              		.loc 1 78 0
 275 01c4 0040C5E5 		strb	r4, [r5, #0]
 276              		.loc 1 79 0
 277 01c8 FEFFFFEB 		bl	radio_add_reg_callback
 278              	.LVL40:
 279              	.L35:
  80:modes51.c     **** 
  81:modes51.c     ****   while (1) {
  82:modes51.c     ****     switch (reg8_table[REG8_MODE]) {
 280              		.loc 1 82 0
 281 01cc 0030D5E5 		ldrb	r3, [r5, #0]	@ zero_extendqisi2
 282 01d0 FF3013E2 		ands	r3, r3, #255
 283 01d4 FCFFFF0A 		beq	.L35
 284 01d8 020053E3 		cmp	r3, #2
  83:modes51.c     ****     case IMODE_IDLE:
  84:modes51.c     ****       break;
  85:modes51.c     ****     case IMODE_SINE_DEMO:
  86:modes51.c     ****       sine_demo_mode();
  87:modes51.c     ****       break;
  88:modes51.c     ****     default:
  89:modes51.c     ****       reg8_table[REG8_MODE] = IMODE_IDLE;
 285              		.loc 1 89 0
 286 01dc 0040C515 		strneb	r4, [r5, #0]
  82:modes51.c     ****     switch (reg8_table[REG8_MODE]) {
 287              		.loc 1 82 0
 288 01e0 F9FFFF1A 		bne	.L35
  86:modes51.c     ****       sine_demo_mode();
 289              		.loc 1 86 0
 290 01e4 FEFFFFEB 		bl	sine_demo_mode
 291              	.LVL41:
  87:modes51.c     ****       break;
 292              		.loc 1 87 0
 293 01e8 F7FFFFEA 		b	.L35
 294              	.L38:
 295              		.align	2
 296              	.L37:
 297 01ec 00000000 		.word	reg8_table
 298 01f0 00000000 		.word	register_handler
 299              		.cfi_endproc
 300              	.LFE2:
 302              		.global	MOTOR_ADDR
 303              		.global	FREQ
 304              		.section	.rodata
 305              		.align	2
 308              	MOTOR_ADDR:
 309 0000 15       		.byte	21
 310 0001 000000   		.space	3
 313              	FREQ:
 314 0004 0000803F 		.word	1065353216
 315              		.text
 316              	.Letext0:
 317              		.file 2 "c:/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 318              		.file 3 "../firmware/radio.h"
 319              		.file 4 "../firmware/registers.h"
 320              		.file 5 "../firmware/robot.h"
 321              		.file 6 "../firmware/hardware.h"
 322              		.file 7 "../firmware/sysTime.h"
 323              		.file 8 "../../common/regdefs.h"
 324              		.file 9 "c:/yagarto/lib/gcc/../../arm-none-eabi/sys-include/math.h"
DEFINED SYMBOLS
                            *ABS*:00000000 modes51.c
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:16     .text:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:18     .text:00000000 register_handler
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:60     .text:00000040 $d
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:74     .text:00000044 $a
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:77     .text:00000044 sine_demo_mode
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:241    .text:00000194 $d
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:252    .text:000001b4 $a
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:255    .text:000001b4 main_mode_loop
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:297    .text:000001ec $d
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:308    .rodata:00000000 MOTOR_ADDR
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:313    .rodata:00000004 FREQ
C:\Users\ncmorand\AppData\Local\Temp\cc35TV95.s:305    .rodata:00000000 $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
reg8_table
__aeabi_ui2f
__aeabi_fdiv
__aeabi_fadd
__aeabi_f2d
__aeabi_dmul
__aeabi_d2f
__aeabi_fmul
__aeabi_f2iz
__aeabi_fcmpge
__aeabi_f2uiz
init_body_module
start_pid
set_color
getSysTICs
getElapsedSysTICs
sin
bus_set
set_rgb
pause
radio_add_reg_callback
