   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"LPC_CANAll.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	CANAll_CANISR_Err
  19              	CANAll_CANISR_Err:
  20              	.LFB4:
  21              		.file 1 "../firmware/LPC_CANAll.c"
   1:../firmware/LPC_CANAll.c **** /**************************************************************************
   2:../firmware/LPC_CANAll.c **** MODULE:    LPC_CANAll
   3:../firmware/LPC_CANAll.c **** CONTAINS:  Philips LPC2000 CAN interface driver.
   4:../firmware/LPC_CANAll.c ****            This driver shows how the CAN interface of the Philips LPC2000
   5:../firmware/LPC_CANAll.c ****            can be used to receive ALL messages on the CANbus.
   6:../firmware/LPC_CANAll.c ****            All incoming messages are copied into a receive queue.
   7:../firmware/LPC_CANAll.c ****            NOTE: This example does not implement any queue overrun handling
   8:../firmware/LPC_CANAll.c **** 		       Compiled and Tested with Keil Tools www.keil.com
   9:../firmware/LPC_CANAll.c **** COPYRIGHT: Embedded Systems Academy, Inc. 2004.
  10:../firmware/LPC_CANAll.c **** LICENSE:   THIS VERSION CREATED FOR FREE DISTRIBUTION
  11:../firmware/LPC_CANAll.c **** 		       FOR PHILIPS SEMICONDUCTORS www.philipsmcu.com
  12:../firmware/LPC_CANAll.c ****            FOR KEIL SOFTWARE www.keil.com
  13:../firmware/LPC_CANAll.c **** VERSION:   1.10, Pf 05-JAN-05, Updates in accordance with errata sheets
  14:../firmware/LPC_CANAll.c **** ---------------------------------------------------------------------------
  15:../firmware/LPC_CANAll.c **** HISTORY:   1.00, Pf 14-JUL-04, First published release
  16:../firmware/LPC_CANAll.c **** 
  17:../firmware/LPC_CANAll.c **** 14. May. 2005:
  18:../firmware/LPC_CANAll.c **** - replaced integer types unsigned int with unsigned long where
  19:../firmware/LPC_CANAll.c ****   appropriate to avoid "target dependent sizeof(int)"
  20:../firmware/LPC_CANAll.c **** - added volatiles to avoid compiler warnings
  21:../firmware/LPC_CANAll.c **** Martin Thomas, Kaiserslautern, Germany
  22:../firmware/LPC_CANAll.c **** <eversmith@heizung-thomas.de>
  23:../firmware/LPC_CANAll.c **** ***************************************************************************/
  24:../firmware/LPC_CANAll.c **** 
  25:../firmware/LPC_CANAll.c **** #include <LPC21XX.H> // LPC21XX Peripheral Registers
  26:../firmware/LPC_CANAll.c **** #include "LPC_CANAll.h"
  27:../firmware/LPC_CANAll.c **** 
  28:../firmware/LPC_CANAll.c **** 
  29:../firmware/LPC_CANAll.c **** /**************************************************************************
  30:../firmware/LPC_CANAll.c **** GLOBAL VARIABLES
  31:../firmware/LPC_CANAll.c **** ***************************************************************************/
  32:../firmware/LPC_CANAll.c **** 
  33:../firmware/LPC_CANAll.c **** // Receive Queue: one queue for each CAN port
  34:../firmware/LPC_CANAll.c **** CANALL_MSG mRxCAN[MAX_CANPORTS][MAX_QUEUE];
  35:../firmware/LPC_CANAll.c **** 
  36:../firmware/LPC_CANAll.c **** // Receive Queue IN pointer
  37:../firmware/LPC_CANAll.c **** short mRxIN[MAX_CANPORTS];
  38:../firmware/LPC_CANAll.c **** 
  39:../firmware/LPC_CANAll.c **** // Receive Queue OUT pointer
  40:../firmware/LPC_CANAll.c **** short mRxOUT[MAX_CANPORTS];
  41:../firmware/LPC_CANAll.c **** 
  42:../firmware/LPC_CANAll.c **** /**************************************************************************
  43:../firmware/LPC_CANAll.c **** PUBLIC FUNCTIONS
  44:../firmware/LPC_CANAll.c **** ***************************************************************************/
  45:../firmware/LPC_CANAll.c **** 
  46:../firmware/LPC_CANAll.c **** /**************************************************************************
  47:../firmware/LPC_CANAll.c **** Initialization of a CAN interface
  48:../firmware/LPC_CANAll.c **** as described in LPC_CANAll.h
  49:../firmware/LPC_CANAll.c **** ***************************************************************************/
  50:../firmware/LPC_CANAll.c **** short CANAll_Init (
  51:../firmware/LPC_CANAll.c ****   unsigned short can_port,    // CAN interface to use
  52:../firmware/LPC_CANAll.c ****   unsigned short can_isrvect, // interrupt vector number to use for Rx ISR (0-15)
  53:../firmware/LPC_CANAll.c ****   unsigned long can_btr        // CAN BTR value used to set CAN baud rate
  54:../firmware/LPC_CANAll.c ****   )
  55:../firmware/LPC_CANAll.c **** {
  56:../firmware/LPC_CANAll.c **** volatile unsigned long *pSFR; // pointer into SFR space
  57:../firmware/LPC_CANAll.c **** volatile unsigned long *pSFR2; // pointer into SFR space
  58:../firmware/LPC_CANAll.c **** unsigned long offset; // offset added to pSFR
  59:../firmware/LPC_CANAll.c **** 
  60:../firmware/LPC_CANAll.c ****   // Double check can_isrvect value
  61:../firmware/LPC_CANAll.c ****   if (can_isrvect > 15)
  62:../firmware/LPC_CANAll.c ****   { // Illegal value for can_isrvect
  63:../firmware/LPC_CANAll.c ****     return 0;
  64:../firmware/LPC_CANAll.c ****   }
  65:../firmware/LPC_CANAll.c **** 
  66:../firmware/LPC_CANAll.c ****   // Double check can_port value
  67:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
  68:../firmware/LPC_CANAll.c ****   { // Illegal value for can_port
  69:../firmware/LPC_CANAll.c ****     return 0;
  70:../firmware/LPC_CANAll.c ****   }
  71:../firmware/LPC_CANAll.c **** 
  72:../firmware/LPC_CANAll.c ****   // Reset IN and OUT pointer
  73:../firmware/LPC_CANAll.c ****   mRxIN[can_port-1] = 0;
  74:../firmware/LPC_CANAll.c ****   mRxOUT[can_port-1] = 0;
  75:../firmware/LPC_CANAll.c **** 
  76:../firmware/LPC_CANAll.c ****   // Enable pins for selected CAN interface
  77:../firmware/LPC_CANAll.c ****   switch (can_port)
  78:../firmware/LPC_CANAll.c ****   {
  79:../firmware/LPC_CANAll.c ****   case 1:
  80:../firmware/LPC_CANAll.c ****     PINSEL1 |= 0x00040000L; // Set bit 18
  81:../firmware/LPC_CANAll.c ****     offset = 0x00000000L; // Use 1st set of CAN registers
  82:../firmware/LPC_CANAll.c ****     break;
  83:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 1)
  84:../firmware/LPC_CANAll.c ****   case 2:
  85:../firmware/LPC_CANAll.c ****     PINSEL1 |= 0x00014000L; // Set bits 14 and 16
  86:../firmware/LPC_CANAll.c ****     offset = 0x00001000L; // Use 2nd set of CAN registers
  87:../firmware/LPC_CANAll.c ****     break;
  88:../firmware/LPC_CANAll.c **** #endif
  89:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 2)
  90:../firmware/LPC_CANAll.c ****   case 3:
  91:../firmware/LPC_CANAll.c ****     PINSEL1 |= 0x00001800L; // Set bits 11 and 12
  92:../firmware/LPC_CANAll.c ****     offset = 0x00002000L; // Use 3rd set of CAN registers
  93:../firmware/LPC_CANAll.c ****     break;
  94:../firmware/LPC_CANAll.c **** #endif
  95:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 3)
  96:../firmware/LPC_CANAll.c ****   case 4:
  97:../firmware/LPC_CANAll.c ****     PINSEL0 |= 0x0F000000L; // Set bits 24 to 27
  98:../firmware/LPC_CANAll.c ****     offset = 0x00003000L; // Use 4th set of CAN registers
  99:../firmware/LPC_CANAll.c ****     break;
 100:../firmware/LPC_CANAll.c **** #endif
 101:../firmware/LPC_CANAll.c ****   default:
 102:../firmware/LPC_CANAll.c ****     return 0; // illegal value used
 103:../firmware/LPC_CANAll.c ****   }
 104:../firmware/LPC_CANAll.c **** 
 105:../firmware/LPC_CANAll.c ****   // Acceptance Filter Mode Register = filter off, receive all
 106:../firmware/LPC_CANAll.c ****   AFMR = 0x00000002L;
 107:../firmware/LPC_CANAll.c **** 
 108:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &C1MOD + offset; // Select Mode register
 109:../firmware/LPC_CANAll.c ****   *pSFR = 1; // Go into Reset mode
 110:../firmware/LPC_CANAll.c **** 
 111:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &C1IER + offset; // Select Interrupt Enable Register
 112:../firmware/LPC_CANAll.c ****   *pSFR = 0;// Disable All Interrupts
 113:../firmware/LPC_CANAll.c **** 
 114:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &C1GSR + offset; // Select Status Register
 115:../firmware/LPC_CANAll.c ****   *pSFR = 0; // Clear Status register
 116:../firmware/LPC_CANAll.c **** 
 117:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &C1BTR + offset; // Select BTR Register
 118:../firmware/LPC_CANAll.c ****   *pSFR = can_btr; // Set bit timing
 119:../firmware/LPC_CANAll.c **** 
 120:../firmware/LPC_CANAll.c ****   // Set and enable receive interrupt
 121:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &VICVectAddr0;
 122:../firmware/LPC_CANAll.c ****   pSFR += can_isrvect; // Set to desired interrupt vector
 123:../firmware/LPC_CANAll.c **** 
 124:../firmware/LPC_CANAll.c ****   pSFR2 = (volatile unsigned long *) &VICVectCntl0;
 125:../firmware/LPC_CANAll.c ****   pSFR2 += can_isrvect; // Set to desired interrupt control
 126:../firmware/LPC_CANAll.c **** 
 127:../firmware/LPC_CANAll.c ****   switch (can_port)
 128:../firmware/LPC_CANAll.c ****   {
 129:../firmware/LPC_CANAll.c ****   case 1:
 130:../firmware/LPC_CANAll.c ****     // Set interrupt vector
 131:../firmware/LPC_CANAll.c ****     *pSFR = (unsigned long) CANAll_CANISR_Rx1;
 132:../firmware/LPC_CANAll.c ****     // Use this Interrupt for CAN Rx1 Interrupt
 133:../firmware/LPC_CANAll.c ****     *pSFR2 = 0x20 | 26;
 134:../firmware/LPC_CANAll.c ****     // Enable CAN Rx1 Interrupt
 135:../firmware/LPC_CANAll.c ****     VICIntEnable = 0x04000000L;
 136:../firmware/LPC_CANAll.c ****     break;
 137:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 1)
 138:../firmware/LPC_CANAll.c ****   case 2:
 139:../firmware/LPC_CANAll.c ****     // Set interrupt vector
 140:../firmware/LPC_CANAll.c ****     *pSFR = (unsigned long) CANAll_CANISR_Rx2;
 141:../firmware/LPC_CANAll.c ****     // Use this Interrupt for CAN Rx2 Interrupt
 142:../firmware/LPC_CANAll.c ****     *pSFR2 = 0x20 | 27;
 143:../firmware/LPC_CANAll.c ****     // Enable CAN Rx2 Interrupt
 144:../firmware/LPC_CANAll.c ****     VICIntEnable = 0x08000000L;
 145:../firmware/LPC_CANAll.c ****     break;
 146:../firmware/LPC_CANAll.c **** #endif
 147:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 2)
 148:../firmware/LPC_CANAll.c ****   case 3:
 149:../firmware/LPC_CANAll.c ****     // Set interrupt vector
 150:../firmware/LPC_CANAll.c ****     *pSFR = (unsigned long) CANAll_CANISR_Rx3;
 151:../firmware/LPC_CANAll.c ****     // Use this Interrupt for CAN Rx3 Interrupt
 152:../firmware/LPC_CANAll.c ****     *pSFR2 = 0x20 | 28;
 153:../firmware/LPC_CANAll.c ****     // Enable CAN Rx3 Interrupt
 154:../firmware/LPC_CANAll.c ****     VICIntEnable = 0x10000000L;
 155:../firmware/LPC_CANAll.c ****     break;
 156:../firmware/LPC_CANAll.c **** #endif
 157:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 3)
 158:../firmware/LPC_CANAll.c ****   case 4:
 159:../firmware/LPC_CANAll.c ****     // Set interrupt vector
 160:../firmware/LPC_CANAll.c ****     *pSFR = (unsigned long) CANAll_CANISR_Rx4;
 161:../firmware/LPC_CANAll.c ****     // Use this Interrupt for CAN Rx4 Interrupt
 162:../firmware/LPC_CANAll.c ****     *pSFR2 = 0x20 | 29;
 163:../firmware/LPC_CANAll.c ****     // Enable CAN Rx4 Interrupt
 164:../firmware/LPC_CANAll.c ****     VICIntEnable = 0x20000000L;
 165:../firmware/LPC_CANAll.c ****     break;
 166:../firmware/LPC_CANAll.c **** #endif
 167:../firmware/LPC_CANAll.c ****   default:
 168:../firmware/LPC_CANAll.c ****     return 0; // illegal value used
 169:../firmware/LPC_CANAll.c ****   }
 170:../firmware/LPC_CANAll.c **** 
 171:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &C1IER + offset; // Select Interrupt register
 172:../firmware/LPC_CANAll.c ****   *pSFR = 1; // Enable Receive Interrupt
 173:../firmware/LPC_CANAll.c **** 
 174:../firmware/LPC_CANAll.c ****   // Enter Normal Operating Mode
 175:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &C1MOD + offset; // Select Mode register
 176:../firmware/LPC_CANAll.c ****   *pSFR = 0; // Operating Mode
 177:../firmware/LPC_CANAll.c **** 
 178:../firmware/LPC_CANAll.c ****   return 1;
 179:../firmware/LPC_CANAll.c **** }
 180:../firmware/LPC_CANAll.c **** 
 181:../firmware/LPC_CANAll.c **** 
 182:../firmware/LPC_CANAll.c **** /**************************************************************************
 183:../firmware/LPC_CANAll.c **** Installing the CAN Err ISR
 184:../firmware/LPC_CANAll.c **** as described in LPC_CANAll.h
 185:../firmware/LPC_CANAll.c **** ***************************************************************************/
 186:../firmware/LPC_CANAll.c **** short CANAll_SetErrIRQ (
 187:../firmware/LPC_CANAll.c ****   unsigned short can_isrvect // interrupt vector number to use for Err ISR (0-15)
 188:../firmware/LPC_CANAll.c ****   )
 189:../firmware/LPC_CANAll.c **** {
 190:../firmware/LPC_CANAll.c **** volatile unsigned long *pSFR; // pointer into SFR space
 191:../firmware/LPC_CANAll.c **** 
 192:../firmware/LPC_CANAll.c ****   // Double check can_isrvect value
 193:../firmware/LPC_CANAll.c ****   if (can_isrvect > 15)
 194:../firmware/LPC_CANAll.c ****   { // Illegal value for can_isrvect
 195:../firmware/LPC_CANAll.c ****     return 0;
 196:../firmware/LPC_CANAll.c ****   }
 197:../firmware/LPC_CANAll.c **** 
 198:../firmware/LPC_CANAll.c ****   // Set and enable err interrupt
 199:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &VICVectAddr0;
 200:../firmware/LPC_CANAll.c ****   pSFR += can_isrvect; // Set to desired interrupt vector
 201:../firmware/LPC_CANAll.c ****   // Set interrupt vector
 202:../firmware/LPC_CANAll.c ****   *pSFR = (unsigned long) CANAll_CANISR_Err;
 203:../firmware/LPC_CANAll.c **** 
 204:../firmware/LPC_CANAll.c ****   pSFR = (volatile unsigned long *) &VICVectCntl0;
 205:../firmware/LPC_CANAll.c ****   pSFR += can_isrvect; // Set to desired interrupt control
 206:../firmware/LPC_CANAll.c ****   *pSFR = 0x20 | 19;
 207:../firmware/LPC_CANAll.c **** 
 208:../firmware/LPC_CANAll.c ****   // Enable Interrupt source
 209:../firmware/LPC_CANAll.c ****   VICIntEnable = 0x00080000L;
 210:../firmware/LPC_CANAll.c **** 
 211:../firmware/LPC_CANAll.c ****   return 1;
 212:../firmware/LPC_CANAll.c **** }
 213:../firmware/LPC_CANAll.c **** 
 214:../firmware/LPC_CANAll.c **** 
 215:../firmware/LPC_CANAll.c **** /**************************************************************************
 216:../firmware/LPC_CANAll.c **** Transmitting a CAN message on a selected CAN interface
 217:../firmware/LPC_CANAll.c **** as described in LPC_CANAll.h
 218:../firmware/LPC_CANAll.c **** ***************************************************************************/
 219:../firmware/LPC_CANAll.c **** short CANAll_PushMessage (
 220:../firmware/LPC_CANAll.c ****   unsigned short can_port,
 221:../firmware/LPC_CANAll.c ****   CANALL_MSG *pTransmitBuf
 222:../firmware/LPC_CANAll.c ****   )
 223:../firmware/LPC_CANAll.c **** {
 224:../firmware/LPC_CANAll.c **** volatile unsigned long *pAddr;
 225:../firmware/LPC_CANAll.c **** unsigned long *pCandata;
 226:../firmware/LPC_CANAll.c **** unsigned long offset;
 227:../firmware/LPC_CANAll.c **** 
 228:../firmware/LPC_CANAll.c ****   // Double check can_port value
 229:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 230:../firmware/LPC_CANAll.c ****   { // Illegal value for can_port
 231:../firmware/LPC_CANAll.c ****     return 0;
 232:../firmware/LPC_CANAll.c ****   }
 233:../firmware/LPC_CANAll.c **** 
 234:../firmware/LPC_CANAll.c ****   switch (can_port)
 235:../firmware/LPC_CANAll.c ****   {
 236:../firmware/LPC_CANAll.c ****   case 1:
 237:../firmware/LPC_CANAll.c ****     offset = 0x00000000L; // Use 1st set of CAN registers
 238:../firmware/LPC_CANAll.c ****     break;
 239:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 1)
 240:../firmware/LPC_CANAll.c ****   case 2:
 241:../firmware/LPC_CANAll.c ****     offset = 0x00001000L; // Use 2nd set of CAN registers
 242:../firmware/LPC_CANAll.c ****     break;
 243:../firmware/LPC_CANAll.c **** #endif
 244:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 2)
 245:../firmware/LPC_CANAll.c ****   case 3:
 246:../firmware/LPC_CANAll.c ****     offset = 0x00002000L; // Use 3rd set of CAN registers
 247:../firmware/LPC_CANAll.c ****     break;
 248:../firmware/LPC_CANAll.c **** #endif
 249:../firmware/LPC_CANAll.c **** #if (MAX_CANPORTS > 3)
 250:../firmware/LPC_CANAll.c ****   case 4:
 251:../firmware/LPC_CANAll.c ****     offset = 0x00003000L; // Use 4th set of CAN registers
 252:../firmware/LPC_CANAll.c ****     break;
 253:../firmware/LPC_CANAll.c **** #endif
 254:../firmware/LPC_CANAll.c ****   default:
 255:../firmware/LPC_CANAll.c ****     return 0; // illegal value used
 256:../firmware/LPC_CANAll.c ****   }
 257:../firmware/LPC_CANAll.c **** 
 258:../firmware/LPC_CANAll.c ****   pAddr = (volatile unsigned long *) &C1SR + offset; // CANSR
 259:../firmware/LPC_CANAll.c ****   if (!(*pAddr & 0x00000004L))
 260:../firmware/LPC_CANAll.c ****   { // Transmit Channel is not available
 261:../firmware/LPC_CANAll.c ****     return 0; // No channel available
 262:../firmware/LPC_CANAll.c ****   }
 263:../firmware/LPC_CANAll.c **** 
 264:../firmware/LPC_CANAll.c ****   // Write DLC, RTR and FF
 265:../firmware/LPC_CANAll.c ****   pAddr = (volatile unsigned long *) &C1TFI1 + offset;
 266:../firmware/LPC_CANAll.c ****   *pAddr = pTransmitBuf->Frame & 0xC00F0000L;
 267:../firmware/LPC_CANAll.c **** 
 268:../firmware/LPC_CANAll.c ****   // Write CAN ID
 269:../firmware/LPC_CANAll.c ****   pAddr++;
 270:../firmware/LPC_CANAll.c ****   *pAddr = pTransmitBuf->MsgID;
 271:../firmware/LPC_CANAll.c **** 
 272:../firmware/LPC_CANAll.c ****   // Write first 4 data bytes
 273:../firmware/LPC_CANAll.c ****   pCandata = (unsigned long *) &(pTransmitBuf->DatA);
 274:../firmware/LPC_CANAll.c ****   pAddr++;
 275:../firmware/LPC_CANAll.c ****   *pAddr = *pCandata;
 276:../firmware/LPC_CANAll.c **** 
 277:../firmware/LPC_CANAll.c ****   // Write second 4 data bytes
 278:../firmware/LPC_CANAll.c ****   pCandata++;
 279:../firmware/LPC_CANAll.c ****   pAddr++;
 280:../firmware/LPC_CANAll.c ****   *pAddr = *pCandata;
 281:../firmware/LPC_CANAll.c **** 
 282:../firmware/LPC_CANAll.c ****   // Write transmission request
 283:../firmware/LPC_CANAll.c ****   pAddr = (volatile unsigned long *) &C1CMR + offset;
 284:../firmware/LPC_CANAll.c ****   *pAddr = 0x21;   // no self transmission, 0x30 for Self Transmission Request Buf 1
 285:../firmware/LPC_CANAll.c **** 
 286:../firmware/LPC_CANAll.c ****   return 1;
 287:../firmware/LPC_CANAll.c **** }
 288:../firmware/LPC_CANAll.c **** 
 289:../firmware/LPC_CANAll.c **** 
 290:../firmware/LPC_CANAll.c **** /**************************************************************************
 291:../firmware/LPC_CANAll.c **** Receiving a CAN message
 292:../firmware/LPC_CANAll.c **** as described in LPC_CANAll.h
 293:../firmware/LPC_CANAll.c **** ***************************************************************************/
 294:../firmware/LPC_CANAll.c **** short CANAll_PullMessage (
 295:../firmware/LPC_CANAll.c ****   unsigned short can_port,
 296:../firmware/LPC_CANAll.c ****   CANALL_MSG *pReceiveBuf
 297:../firmware/LPC_CANAll.c ****   )
 298:../firmware/LPC_CANAll.c **** {
 299:../firmware/LPC_CANAll.c **** unsigned long *pSrc; // Source pointer
 300:../firmware/LPC_CANAll.c **** unsigned long *pDst; // Destination pointer
 301:../firmware/LPC_CANAll.c **** 
 302:../firmware/LPC_CANAll.c ****   // Double check can_port value
 303:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 304:../firmware/LPC_CANAll.c ****   { // Illegal value for can_port
 305:../firmware/LPC_CANAll.c ****     return 0;
 306:../firmware/LPC_CANAll.c ****   }
 307:../firmware/LPC_CANAll.c ****   can_port--; // Adjust to 0 - MAX_CANPORTS-1
 308:../firmware/LPC_CANAll.c **** 
 309:../firmware/LPC_CANAll.c ****   // Check if something is in RxQueue
 310:../firmware/LPC_CANAll.c ****   if ((mRxIN[can_port]) == (mRxOUT[can_port]))
 311:../firmware/LPC_CANAll.c ****   { // Queue is empty
 312:../firmware/LPC_CANAll.c ****     return 0;
 313:../firmware/LPC_CANAll.c ****   }
 314:../firmware/LPC_CANAll.c ****   // Pointers are different, so something is in queue
 315:../firmware/LPC_CANAll.c **** 
 316:../firmware/LPC_CANAll.c ****   // Initialize pointers
 317:../firmware/LPC_CANAll.c ****   pSrc = (unsigned long *) &(mRxCAN[can_port][mRxOUT[can_port]]);
 318:../firmware/LPC_CANAll.c ****   pDst = (unsigned long *) &(pReceiveBuf->Frame);
 319:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy Frame
 320:../firmware/LPC_CANAll.c **** 
 321:../firmware/LPC_CANAll.c ****   pSrc++;
 322:../firmware/LPC_CANAll.c ****   pDst++;
 323:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy MsgID
 324:../firmware/LPC_CANAll.c **** 
 325:../firmware/LPC_CANAll.c ****   pSrc++;
 326:../firmware/LPC_CANAll.c ****   pDst++;
 327:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy DatA
 328:../firmware/LPC_CANAll.c **** 
 329:../firmware/LPC_CANAll.c ****   pSrc++;
 330:../firmware/LPC_CANAll.c ****   pDst++;
 331:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy DatB
 332:../firmware/LPC_CANAll.c **** 
 333:../firmware/LPC_CANAll.c ****   // Adjust OUT pointer
 334:../firmware/LPC_CANAll.c ****   mRxOUT[can_port]++;
 335:../firmware/LPC_CANAll.c ****   if (mRxOUT[can_port] >= MAX_QUEUE)
 336:../firmware/LPC_CANAll.c ****   {
 337:../firmware/LPC_CANAll.c ****     mRxOUT[can_port] = 0;
 338:../firmware/LPC_CANAll.c ****   }
 339:../firmware/LPC_CANAll.c **** 
 340:../firmware/LPC_CANAll.c ****   return 1;
 341:../firmware/LPC_CANAll.c **** }
 342:../firmware/LPC_CANAll.c **** 
 343:../firmware/LPC_CANAll.c **** 
 344:../firmware/LPC_CANAll.c **** /**************************************************************************
 345:../firmware/LPC_CANAll.c **** PRIVATE FUNCTIONS
 346:../firmware/LPC_CANAll.c **** ***************************************************************************/
 347:../firmware/LPC_CANAll.c **** 
 348:../firmware/LPC_CANAll.c **** /**************************************************************************
 349:../firmware/LPC_CANAll.c **** DOES:    Interrupt Service Routine for CAN Errors
 350:../firmware/LPC_CANAll.c **** GLOBALS: none
 351:../firmware/LPC_CANAll.c **** RETURNS: nothing
 352:../firmware/LPC_CANAll.c **** ***************************************************************************/
 353:../firmware/LPC_CANAll.c **** void CANAll_CANISR_Err (
 354:../firmware/LPC_CANAll.c ****   void
 355:../firmware/LPC_CANAll.c ****   )
 356:../firmware/LPC_CANAll.c **** {
  22              		.loc 1 356 0
  23              		.cfi_startproc
  24              		@ Interrupt Service Routine.
  25              		@ args = 0, pretend = 0, frame = 0
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27              		@ link register save eliminated.
  28 0000 0C002DE9 		stmfd	sp!, {r2, r3}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 2, -8
  32              		.cfi_offset 3, -4
 357:../firmware/LPC_CANAll.c **** 
 358:../firmware/LPC_CANAll.c ****   IO1PIN = (1 << 18);
  33              		.loc 1 358 0
  34 0004 08309FE5 		ldr	r3, .L3
  35 0008 0127A0E3 		mov	r2, #262144
  36 000c 102083E5 		str	r2, [r3, #16]
  37              	.L2:
  38 0010 FEFFFFEA 		b	.L2
  39              	.L4:
  40              		.align	2
  41              	.L3:
  42 0014 008002E0 		.word	-536707072
  43              		.cfi_endproc
  44              	.LFE4:
  46              		.align	2
  47              		.global	CANAll_CANISR_Rx1
  49              	CANAll_CANISR_Rx1:
  50              	.LFB5:
 359:../firmware/LPC_CANAll.c ****   // DEBUG VERSION: do not return from Errors
 360:../firmware/LPC_CANAll.c ****   // Replace this with application specific error handling
 361:../firmware/LPC_CANAll.c ****   while (1)
 362:../firmware/LPC_CANAll.c ****   {
 363:../firmware/LPC_CANAll.c ****   }
 364:../firmware/LPC_CANAll.c ****   VICVectAddr = 0xFFFFFFFFL; // acknowledge Interrupt
 365:../firmware/LPC_CANAll.c **** }
 366:../firmware/LPC_CANAll.c **** 
 367:../firmware/LPC_CANAll.c **** 
 368:../firmware/LPC_CANAll.c **** /**************************************************************************
 369:../firmware/LPC_CANAll.c **** DOES:    Interrupt Service Routine for CAN receive on CAN interface 1
 370:../firmware/LPC_CANAll.c **** GLOBALS: Copies the received message into the gRxCAN[0][] array
 371:../firmware/LPC_CANAll.c **** RETURNS: nothing
 372:../firmware/LPC_CANAll.c **** ***************************************************************************/
 373:../firmware/LPC_CANAll.c **** void CANAll_CANISR_Rx1 (
 374:../firmware/LPC_CANAll.c ****   void
 375:../firmware/LPC_CANAll.c ****   )
 376:../firmware/LPC_CANAll.c **** {
  51              		.loc 1 376 0
  52              		.cfi_startproc
  53              		@ Interrupt Service Routine.
  54              		@ args = 0, pretend = 0, frame = 0
  55              		@ frame_needed = 0, uses_anonymous_args = 0
  56              		@ link register save eliminated.
  57 0018 3F102DE9 		stmfd	sp!, {r0, r1, r2, r3, r4, r5, ip}
  58              	.LCFI1:
  59              		.cfi_def_cfa_offset 28
  60              		.cfi_offset 0, -28
  61              		.cfi_offset 1, -24
  62              		.cfi_offset 2, -20
  63              		.cfi_offset 3, -16
  64              		.cfi_offset 4, -12
  65              		.cfi_offset 5, -8
  66              		.cfi_offset 12, -4
 377:../firmware/LPC_CANAll.c **** unsigned long *pDest;
 378:../firmware/LPC_CANAll.c **** //static char bit = 0;
 379:../firmware/LPC_CANAll.c **** 
 380:../firmware/LPC_CANAll.c **** /*
 381:../firmware/LPC_CANAll.c ****   bit = !bit;
 382:../firmware/LPC_CANAll.c ****   if (bit) {
 383:../firmware/LPC_CANAll.c ****     IO0SET = (1 << 12);   // LED on
 384:../firmware/LPC_CANAll.c ****   } else {
 385:../firmware/LPC_CANAll.c ****     IO0CLR = (1 << 12);   // LED off
 386:../firmware/LPC_CANAll.c ****   }
 387:../firmware/LPC_CANAll.c **** */
 388:../firmware/LPC_CANAll.c **** 
 389:../firmware/LPC_CANAll.c ****   // initialize destination pointer
 390:../firmware/LPC_CANAll.c ****   pDest = (unsigned long *) &(mRxCAN[0][mRxIN[0]]);
 391:../firmware/LPC_CANAll.c ****   *pDest = C1RFS;  // Frame
  67              		.loc 1 391 0
  68 001c 64309FE5 		ldr	r3, .L8
 390:../firmware/LPC_CANAll.c ****   pDest = (unsigned long *) &(mRxCAN[0][mRxIN[0]]);
  69              		.loc 1 390 0
  70 0020 64209FE5 		ldr	r2, .L8+4
  71              		.loc 1 391 0
  72 0024 205093E5 		ldr	r5, [r3, #32]
 390:../firmware/LPC_CANAll.c ****   pDest = (unsigned long *) &(mRxCAN[0][mRxIN[0]]);
  73              		.loc 1 390 0
  74 0028 F0C0D2E1 		ldrsh	ip, [r2, #0]
  75 002c 5C009FE5 		ldr	r0, .L8+8
  76              		.loc 1 391 0
  77 0030 0C5280E7 		str	r5, [r0, ip, asl #4]
 390:../firmware/LPC_CANAll.c ****   pDest = (unsigned long *) &(mRxCAN[0][mRxIN[0]]);
  78              		.loc 1 390 0
  79 0034 0C1280E0 		add	r1, r0, ip, asl #4
  80              	.LVL0:
 392:../firmware/LPC_CANAll.c **** 
 393:../firmware/LPC_CANAll.c ****   pDest++;
 394:../firmware/LPC_CANAll.c ****   *pDest = C1RID; // ID
  81              		.loc 1 394 0
  82 0038 240093E5 		ldr	r0, [r3, #36]
  83 003c 040081E5 		str	r0, [r1, #4]
  84              	.LVL1:
 395:../firmware/LPC_CANAll.c **** 
 396:../firmware/LPC_CANAll.c ****   pDest++;
 397:../firmware/LPC_CANAll.c ****   *pDest = C1RDA; // Data A
  85              		.loc 1 397 0
  86 0040 280093E5 		ldr	r0, [r3, #40]
  87 0044 080081E5 		str	r0, [r1, #8]
  88              	.LVL2:
 390:../firmware/LPC_CANAll.c ****   pDest = (unsigned long *) &(mRxCAN[0][mRxIN[0]]);
  89              		.loc 1 390 0
  90 0048 B040D2E1 		ldrh	r4, [r2, #0]
 398:../firmware/LPC_CANAll.c **** 
 399:../firmware/LPC_CANAll.c ****   pDest++;
 400:../firmware/LPC_CANAll.c ****   *pDest = C1RDB; // Data B
  91              		.loc 1 400 0
  92 004c 2C0093E5 		ldr	r0, [r3, #44]
  93 0050 0C0081E5 		str	r0, [r1, #12]
 401:../firmware/LPC_CANAll.c **** 
 402:../firmware/LPC_CANAll.c ****   // Adjust IN pointer
 403:../firmware/LPC_CANAll.c ****   mRxIN[0]++;
  94              		.loc 1 403 0
  95 0054 011084E2 		add	r1, r4, #1
  96              	.LVL3:
  97 0058 0118A0E1 		mov	r1, r1, asl #16
 404:../firmware/LPC_CANAll.c ****   if (mRxIN[0] >= MAX_QUEUE)
  98              		.loc 1 404 0
  99 005c 060751E3 		cmp	r1, #1572864
 100 0060 2108A0E1 		mov	r0, r1, lsr #16
 405:../firmware/LPC_CANAll.c ****   {
 406:../firmware/LPC_CANAll.c ****     mRxIN[0] = 0;
 101              		.loc 1 406 0
 102 0064 0010A0C3 		movgt	r1, #0
 403:../firmware/LPC_CANAll.c ****   mRxIN[0]++;
 103              		.loc 1 403 0
 104 0068 B000C2D1 		strleh	r0, [r2, #0]	@ movhi
 105              		.loc 1 406 0
 106 006c B010C2C1 		strgth	r1, [r2, #0]	@ movhi
 407:../firmware/LPC_CANAll.c ****   }
 408:../firmware/LPC_CANAll.c **** 
 409:../firmware/LPC_CANAll.c ****   C1CMR = 0x04; // release receive buffer
 107              		.loc 1 409 0
 108 0070 0420A0E3 		mov	r2, #4
 109 0074 042083E5 		str	r2, [r3, #4]
 410:../firmware/LPC_CANAll.c ****   VICVectAddr = 0xFFFFFFFFL; // acknowledge Interrupt
 110              		.loc 1 410 0
 111 0078 0030E0E3 		mvn	r3, #0
 112 007c CF3F03E5 		str	r3, [r3, #-4047]
 411:../firmware/LPC_CANAll.c **** }
 113              		.loc 1 411 0
 114 0080 3F10BDE8 		ldmfd	sp!, {r0, r1, r2, r3, r4, r5, ip}
 115 0084 04F05EE2 		subs	pc, lr, #4
 116              	.L9:
 117              		.align	2
 118              	.L8:
 119 0088 004004E0 		.word	-536592384
 120 008c 00000000 		.word	mRxIN
 121 0090 00000000 		.word	mRxCAN
 122              		.cfi_endproc
 123              	.LFE5:
 125              		.align	2
 126              		.global	CANAll_Init
 128              	CANAll_Init:
 129              	.LFB0:
  55:../firmware/LPC_CANAll.c **** {
 130              		.loc 1 55 0
 131              		.cfi_startproc
 132              		@ Function supports interworking.
 133              		@ args = 0, pretend = 0, frame = 0
 134              		@ frame_needed = 0, uses_anonymous_args = 0
 135              		@ link register save eliminated.
 136              	.LVL4:
  61:../firmware/LPC_CANAll.c ****   if (can_isrvect > 15)
 137              		.loc 1 61 0
 138 0094 0F0051E3 		cmp	r1, #15
  55:../firmware/LPC_CANAll.c **** {
 139              		.loc 1 55 0
 140 0098 04402DE5 		str	r4, [sp, #-4]!
 141              	.LCFI2:
 142              		.cfi_def_cfa_offset 4
 143              		.cfi_offset 4, -4
 144 009c 0030A0E3 		mov	r3, #0
  61:../firmware/LPC_CANAll.c ****   if (can_isrvect > 15)
 145              		.loc 1 61 0
 146 00a0 1C00008A 		bhi	.L11
  67:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 147              		.loc 1 67 0
 148 00a4 010050E3 		cmp	r0, #1
 149 00a8 1A00001A 		bne	.L11
  73:../firmware/LPC_CANAll.c ****   mRxIN[can_port-1] = 0;
 150              		.loc 1 73 0
 151 00ac 74C09FE5 		ldr	ip, .L14
 152 00b0 B030CCE1 		strh	r3, [ip, #0]	@ movhi
  74:../firmware/LPC_CANAll.c ****   mRxOUT[can_port-1] = 0;
 153              		.loc 1 74 0
 154 00b4 70C09FE5 		ldr	ip, .L14+4
 155 00b8 B030CCE1 		strh	r3, [ip, #0]	@ movhi
  80:../firmware/LPC_CANAll.c ****     PINSEL1 |= 0x00040000L; // Set bit 18
 156              		.loc 1 80 0
 157 00bc 6CC09FE5 		ldr	ip, .L14+8
 158 00c0 04409CE5 		ldr	r4, [ip, #4]
 159 00c4 014784E3 		orr	r4, r4, #262144
 160 00c8 04408CE5 		str	r4, [ip, #4]
 161              	.LVL5:
 106:../firmware/LPC_CANAll.c ****   AFMR = 0x00000002L;
 162              		.loc 1 106 0
 163 00cc 0240A0E3 		mov	r4, #2
 122:../firmware/LPC_CANAll.c ****   pSFR += can_isrvect; // Set to desired interrupt vector
 164              		.loc 1 122 0
 165 00d0 1114A0E1 		mov	r1, r1, asl r4
 166              	.LVL6:
 106:../firmware/LPC_CANAll.c ****   AFMR = 0x00000002L;
 167              		.loc 1 106 0
 168 00d4 01C88CE2 		add	ip, ip, #65536
 169 00d8 00408CE5 		str	r4, [ip, #0]
 170              	.LVL7:
 109:../firmware/LPC_CANAll.c ****   *pSFR = 1; // Go into Reset mode
 171              		.loc 1 109 0
 172 00dc 02C98CE2 		add	ip, ip, #32768
 173 00e0 00008CE5 		str	r0, [ip, #0]
 174              	.LVL8:
 112:../firmware/LPC_CANAll.c ****   *pSFR = 0;// Disable All Interrupts
 175              		.loc 1 112 0
 176 00e4 10308CE5 		str	r3, [ip, #16]
 177              	.LVL9:
 115:../firmware/LPC_CANAll.c ****   *pSFR = 0; // Clear Status register
 178              		.loc 1 115 0
 179 00e8 08308CE5 		str	r3, [ip, #8]
 180              	.LVL10:
 118:../firmware/LPC_CANAll.c ****   *pSFR = can_btr; // Set bit timing
 181              		.loc 1 118 0
 182 00ec 14208CE5 		str	r2, [ip, #20]
 183              	.LVL11:
 131:../firmware/LPC_CANAll.c ****     *pSFR = (unsigned long) CANAll_CANISR_Rx1;
 184              		.loc 1 131 0
 185 00f0 3C209FE5 		ldr	r2, .L14+12
 186              	.LVL12:
 187 00f4 002F01E5 		str	r2, [r1, #-3840]
 133:../firmware/LPC_CANAll.c ****     *pSFR2 = 0x20 | 26;
 188              		.loc 1 133 0
 189 00f8 3A20A0E3 		mov	r2, #58
 190 00fc 002E01E5 		str	r2, [r1, #-3584]
 135:../firmware/LPC_CANAll.c ****     VICIntEnable = 0x04000000L;
 191              		.loc 1 135 0
 192 0100 0113A0E3 		mov	r1, #67108864
 193              	.LVL13:
 194 0104 0020E0E3 		mvn	r2, #0
 195 0108 EF1F02E5 		str	r1, [r2, #-4079]
 196              	.LVL14:
 172:../firmware/LPC_CANAll.c ****   *pSFR = 1; // Enable Receive Interrupt
 197              		.loc 1 172 0
 198 010c 10008CE5 		str	r0, [ip, #16]
 199              	.LVL15:
 176:../firmware/LPC_CANAll.c ****   *pSFR = 0; // Operating Mode
 200              		.loc 1 176 0
 201 0110 00308CE5 		str	r3, [ip, #0]
 178:../firmware/LPC_CANAll.c ****   return 1;
 202              		.loc 1 178 0
 203 0114 0030A0E1 		mov	r3, r0
 204              	.LVL16:
 205              	.L11:
 206 0118 0308A0E1 		mov	r0, r3, asl #16
 207              	.LVL17:
 179:../firmware/LPC_CANAll.c **** }
 208              		.loc 1 179 0
 209 011c 4008A0E1 		mov	r0, r0, asr #16
 210 0120 1000BDE8 		ldmfd	sp!, {r4}
 211 0124 1EFF2FE1 		bx	lr
 212              	.L15:
 213              		.align	2
 214              	.L14:
 215 0128 00000000 		.word	mRxIN
 216 012c 00000000 		.word	mRxOUT
 217 0130 00C002E0 		.word	-536690688
 218 0134 00000000 		.word	CANAll_CANISR_Rx1
 219              		.cfi_endproc
 220              	.LFE0:
 222              		.align	2
 223              		.global	CANAll_SetErrIRQ
 225              	CANAll_SetErrIRQ:
 226              	.LFB1:
 189:../firmware/LPC_CANAll.c **** {
 227              		.loc 1 189 0
 228              		.cfi_startproc
 229              		@ Function supports interworking.
 230              		@ args = 0, pretend = 0, frame = 0
 231              		@ frame_needed = 0, uses_anonymous_args = 0
 232              		@ link register save eliminated.
 233              	.LVL18:
 193:../firmware/LPC_CANAll.c ****   if (can_isrvect > 15)
 234              		.loc 1 193 0
 235 0138 0F0050E3 		cmp	r0, #15
 236 013c 0900008A 		bhi	.L18
 237              	.LVL19:
 202:../firmware/LPC_CANAll.c ****   *pSFR = (unsigned long) CANAll_CANISR_Err;
 238              		.loc 1 202 0
 239 0140 28309FE5 		ldr	r3, .L19
 200:../firmware/LPC_CANAll.c ****   pSFR += can_isrvect; // Set to desired interrupt vector
 240              		.loc 1 200 0
 241 0144 0001A0E1 		mov	r0, r0, asl #2
 242              	.LVL20:
 202:../firmware/LPC_CANAll.c ****   *pSFR = (unsigned long) CANAll_CANISR_Err;
 243              		.loc 1 202 0
 244 0148 003F00E5 		str	r3, [r0, #-3840]
 245              	.LVL21:
 206:../firmware/LPC_CANAll.c ****   *pSFR = 0x20 | 19;
 246              		.loc 1 206 0
 247 014c 3330A0E3 		mov	r3, #51
 248 0150 003E00E5 		str	r3, [r0, #-3584]
 209:../firmware/LPC_CANAll.c ****   VICIntEnable = 0x00080000L;
 249              		.loc 1 209 0
 250 0154 0227A0E3 		mov	r2, #524288
 251 0158 0030E0E3 		mvn	r3, #0
 252 015c EF2F03E5 		str	r2, [r3, #-4079]
 211:../firmware/LPC_CANAll.c ****   return 1;
 253              		.loc 1 211 0
 254 0160 0100A0E3 		mov	r0, #1
 255              	.LVL22:
 256 0164 1EFF2FE1 		bx	lr
 257              	.LVL23:
 258              	.L18:
 195:../firmware/LPC_CANAll.c ****     return 0;
 259              		.loc 1 195 0
 260 0168 0000A0E3 		mov	r0, #0
 261              	.LVL24:
 212:../firmware/LPC_CANAll.c **** }
 262              		.loc 1 212 0
 263 016c 1EFF2FE1 		bx	lr
 264              	.L20:
 265              		.align	2
 266              	.L19:
 267 0170 00000000 		.word	CANAll_CANISR_Err
 268              		.cfi_endproc
 269              	.LFE1:
 271              		.align	2
 272              		.global	CANAll_PushMessage
 274              	CANAll_PushMessage:
 275              	.LFB2:
 223:../firmware/LPC_CANAll.c **** {
 276              		.loc 1 223 0
 277              		.cfi_startproc
 278              		@ Function supports interworking.
 279              		@ args = 0, pretend = 0, frame = 0
 280              		@ frame_needed = 0, uses_anonymous_args = 0
 281              		@ link register save eliminated.
 282              	.LVL25:
 229:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 283              		.loc 1 229 0
 284 0174 010050E3 		cmp	r0, #1
 231:../firmware/LPC_CANAll.c ****     return 0;
 285              		.loc 1 231 0
 286 0178 0000A013 		movne	r0, #0
 287              	.LVL26:
 229:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 288              		.loc 1 229 0
 289 017c 1100001A 		bne	.L22
 290              	.LVL27:
 259:../firmware/LPC_CANAll.c ****   if (!(*pAddr & 0x00000004L))
 291              		.loc 1 259 0
 292 0180 4C309FE5 		ldr	r3, .L25
 293 0184 1C2093E5 		ldr	r2, [r3, #28]
 294 0188 042012E2 		ands	r2, r2, #4
 231:../firmware/LPC_CANAll.c ****     return 0;
 295              		.loc 1 231 0
 296 018c 0200A001 		moveq	r0, r2
 259:../firmware/LPC_CANAll.c ****   if (!(*pAddr & 0x00000004L))
 297              		.loc 1 259 0
 298 0190 0C00000A 		beq	.L22
 299              	.LVL28:
 266:../firmware/LPC_CANAll.c ****   *pAddr = pTransmitBuf->Frame & 0xC00F0000L;
 300              		.loc 1 266 0
 301 0194 00C091E5 		ldr	ip, [r1, #0]
 302 0198 38209FE5 		ldr	r2, .L25+4
 303 019c 02200CE0 		and	r2, ip, r2
 304 01a0 302083E5 		str	r2, [r3, #48]
 305              	.LVL29:
 270:../firmware/LPC_CANAll.c ****   *pAddr = pTransmitBuf->MsgID;
 306              		.loc 1 270 0
 307 01a4 042091E5 		ldr	r2, [r1, #4]
 308 01a8 342083E5 		str	r2, [r3, #52]
 309              	.LVL30:
 275:../firmware/LPC_CANAll.c ****   *pAddr = *pCandata;
 310              		.loc 1 275 0
 311 01ac 082091E5 		ldr	r2, [r1, #8]
 312 01b0 382083E5 		str	r2, [r3, #56]
 313              	.LVL31:
 280:../firmware/LPC_CANAll.c ****   *pAddr = *pCandata;
 314              		.loc 1 280 0
 315 01b4 0C2091E5 		ldr	r2, [r1, #12]
 316 01b8 3C2083E5 		str	r2, [r3, #60]
 317              	.LVL32:
 284:../firmware/LPC_CANAll.c ****   *pAddr = 0x21;   // no self transmission, 0x30 for Self Transmission Request Buf 1
 318              		.loc 1 284 0
 319 01bc 2120A0E3 		mov	r2, #33
 320 01c0 042083E5 		str	r2, [r3, #4]
 286:../firmware/LPC_CANAll.c ****   return 1;
 321              		.loc 1 286 0
 322 01c4 FFFFFFEA 		b	.L22
 323              	.LVL33:
 324              	.L22:
 325 01c8 0008A0E1 		mov	r0, r0, asl #16
 287:../firmware/LPC_CANAll.c **** }
 326              		.loc 1 287 0
 327 01cc 4008A0E1 		mov	r0, r0, asr #16
 328 01d0 1EFF2FE1 		bx	lr
 329              	.L26:
 330              		.align	2
 331              	.L25:
 332 01d4 004004E0 		.word	-536592384
 333 01d8 00000FC0 		.word	-1072758784
 334              		.cfi_endproc
 335              	.LFE2:
 337              		.align	2
 338              		.global	CANAll_PullMessage
 340              	CANAll_PullMessage:
 341              	.LFB3:
 298:../firmware/LPC_CANAll.c **** {
 342              		.loc 1 298 0
 343              		.cfi_startproc
 344              		@ Function supports interworking.
 345              		@ args = 0, pretend = 0, frame = 0
 346              		@ frame_needed = 0, uses_anonymous_args = 0
 347              		@ link register save eliminated.
 348              	.LVL34:
 303:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 349              		.loc 1 303 0
 350 01dc 010050E3 		cmp	r0, #1
 298:../firmware/LPC_CANAll.c **** {
 351              		.loc 1 298 0
 352 01e0 30002DE9 		stmfd	sp!, {r4, r5}
 353              	.LCFI3:
 354              		.cfi_def_cfa_offset 8
 355              		.cfi_offset 4, -8
 356              		.cfi_offset 5, -4
 303:../firmware/LPC_CANAll.c ****   if ((can_port < 1) || (can_port > MAX_CANPORTS))
 357              		.loc 1 303 0
 358 01e4 1800001A 		bne	.L31
 359              	.LVL35:
 310:../firmware/LPC_CANAll.c ****   if ((mRxIN[can_port]) == (mRxOUT[can_port]))
 360              		.loc 1 310 0
 361 01e8 70309FE5 		ldr	r3, .L32
 362 01ec 70209FE5 		ldr	r2, .L32+4
 363 01f0 F0C0D3E1 		ldrsh	ip, [r3, #0]
 364 01f4 F020D2E1 		ldrsh	r2, [r2, #0]
 365 01f8 0C0052E1 		cmp	r2, ip
 366 01fc B050D3E1 		ldrh	r5, [r3, #0]
 367 0200 1100000A 		beq	.L31
 317:../firmware/LPC_CANAll.c ****   pSrc = (unsigned long *) &(mRxCAN[can_port][mRxOUT[can_port]]);
 368              		.loc 1 317 0
 369 0204 5C409FE5 		ldr	r4, .L32+8
 370 0208 0C2284E0 		add	r2, r4, ip, asl #4
 371              	.LVL36:
 319:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy Frame
 372              		.loc 1 319 0
 373 020c 0CC294E7 		ldr	ip, [r4, ip, asl #4]
 374 0210 00C081E5 		str	ip, [r1, #0]
 375              	.LVL37:
 323:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy MsgID
 376              		.loc 1 323 0
 377 0214 04C092E5 		ldr	ip, [r2, #4]
 378 0218 04C081E5 		str	ip, [r1, #4]
 379              	.LVL38:
 327:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy DatA
 380              		.loc 1 327 0
 381 021c 08C092E5 		ldr	ip, [r2, #8]
 382 0220 08C081E5 		str	ip, [r1, #8]
 383              	.LVL39:
 331:../firmware/LPC_CANAll.c ****   *pDst = *pSrc; // Copy DatB
 384              		.loc 1 331 0
 385 0224 0C2092E5 		ldr	r2, [r2, #12]
 386              	.LVL40:
 387 0228 0C2081E5 		str	r2, [r1, #12]
 334:../firmware/LPC_CANAll.c ****   mRxOUT[can_port]++;
 388              		.loc 1 334 0
 389 022c 012085E2 		add	r2, r5, #1
 390 0230 0228A0E1 		mov	r2, r2, asl #16
 335:../firmware/LPC_CANAll.c ****   if (mRxOUT[can_port] >= MAX_QUEUE)
 391              		.loc 1 335 0
 392 0234 060752E3 		cmp	r2, #1572864
 393 0238 2218A0E1 		mov	r1, r2, lsr #16
 394              	.LVL41:
 337:../firmware/LPC_CANAll.c ****     mRxOUT[can_port] = 0;
 395              		.loc 1 337 0
 396 023c 0020A0C3 		movgt	r2, #0
 334:../firmware/LPC_CANAll.c ****   mRxOUT[can_port]++;
 397              		.loc 1 334 0
 398 0240 B010C3D1 		strleh	r1, [r3, #0]	@ movhi
 337:../firmware/LPC_CANAll.c ****     mRxOUT[can_port] = 0;
 399              		.loc 1 337 0
 400 0244 B020C3C1 		strgth	r2, [r3, #0]	@ movhi
 401 0248 000000EA 		b	.L28
 402              	.LVL42:
 403              	.L31:
 305:../firmware/LPC_CANAll.c ****     return 0;
 404              		.loc 1 305 0
 405 024c 0000A0E3 		mov	r0, #0
 406              	.LVL43:
 407              	.L28:
 408 0250 0008A0E1 		mov	r0, r0, asl #16
 341:../firmware/LPC_CANAll.c **** }
 409              		.loc 1 341 0
 410 0254 4008A0E1 		mov	r0, r0, asr #16
 411 0258 3000BDE8 		ldmfd	sp!, {r4, r5}
 412 025c 1EFF2FE1 		bx	lr
 413              	.L33:
 414              		.align	2
 415              	.L32:
 416 0260 00000000 		.word	mRxOUT
 417 0264 00000000 		.word	mRxIN
 418 0268 00000000 		.word	mRxCAN
 419              		.cfi_endproc
 420              	.LFE3:
 422              		.comm	mRxOUT,2,2
 423              		.comm	mRxIN,2,2
 424              		.comm	mRxCAN,400,4
 425              	.Letext0:
 426              		.file 2 "../firmware/lpcGPIO.h"
 427              		.file 3 "../firmware/lpcPIN.h"
 428              		.file 4 "../firmware/lpcVIC.h"
 429              		.file 5 "../firmware/LPC_CANAll.h"
DEFINED SYMBOLS
                            *ABS*:00000000 LPC_CANAll.c
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:16     .text:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:19     .text:00000000 CANAll_CANISR_Err
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:42     .text:00000014 $d
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:46     .text:00000018 $a
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:49     .text:00000018 CANAll_CANISR_Rx1
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:119    .text:00000088 $d
                            *COM*:00000002 mRxIN
                            *COM*:00000190 mRxCAN
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:125    .text:00000094 $a
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:128    .text:00000094 CANAll_Init
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:215    .text:00000128 $d
                            *COM*:00000002 mRxOUT
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:222    .text:00000138 $a
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:225    .text:00000138 CANAll_SetErrIRQ
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:267    .text:00000170 $d
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:271    .text:00000174 $a
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:274    .text:00000174 CANAll_PushMessage
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:332    .text:000001d4 $d
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:337    .text:000001dc $a
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:340    .text:000001dc CANAll_PullMessage
C:\Users\ncmorand\AppData\Local\Temp\ccTnaX0N.s:416    .text:00000260 $d
                     .debug_frame:00000010 $d

NO UNDEFINED SYMBOLS
