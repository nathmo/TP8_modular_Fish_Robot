   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"radio.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  18              	callbacks_call_all:
  19              	.LFB2:
  20              		.file 1 "../firmware/radio.c"
   1:../firmware/radio.c **** /******************************************************************************
   2:../firmware/radio.c ****  * radio.c - Routines for handling the radio communication protocol
   3:../firmware/radio.c ****  * Alessandro Crespi & Jeremie Knuesel, Sep. 2010, updated March 2013
   4:../firmware/radio.c ****  *****************************************************************************/
   5:../firmware/radio.c **** 
   6:../firmware/radio.c **** #include <stdint.h>
   7:../firmware/radio.c **** #include "radio.h"
   8:../firmware/radio.c **** #include "registers.h"
   9:../firmware/radio.c **** #include "uart.h"
  10:../firmware/radio.c **** #include "uartISR.h"
  11:../firmware/radio.c **** #include "utils.h"
  12:../firmware/radio.c **** 
  13:../firmware/radio.c **** // Register banks
  14:../firmware/radio.c **** volatile uint8_t reg8_table[REG8_MAX];       ///< 8-bit register bank
  15:../firmware/radio.c **** volatile uint16_t reg16_table[REG16_MAX];    ///< 16-bit register bank
  16:../firmware/radio.c **** volatile uint32_t reg32_table[REG32_MAX];    ///< 32-bit register bank
  17:../firmware/radio.c **** 
  18:../firmware/radio.c **** #define MAX_REG_CALLBACKS 16
  19:../firmware/radio.c **** 
  20:../firmware/radio.c **** // Callback function addresses (NULL if entry unused)
  21:../firmware/radio.c **** static register_callback_t reg_callbacks[MAX_REG_CALLBACKS];
  22:../firmware/radio.c **** static RadioData regdata2;
  23:../firmware/radio.c **** 
  24:../firmware/radio.c **** void radio_add_reg_callback(register_callback_t addr)
  25:../firmware/radio.c **** {
  26:../firmware/radio.c ****   uint8_t i;
  27:../firmware/radio.c **** 
  28:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
  29:../firmware/radio.c ****     if (reg_callbacks[i] == NULL) {
  30:../firmware/radio.c ****       reg_callbacks[i] = addr;
  31:../firmware/radio.c ****       break;
  32:../firmware/radio.c ****     }
  33:../firmware/radio.c ****   }
  34:../firmware/radio.c **** }
  35:../firmware/radio.c **** 
  36:../firmware/radio.c **** void radio_del_reg_callback(register_callback_t addr)
  37:../firmware/radio.c **** {
  38:../firmware/radio.c ****   uint8_t i;
  39:../firmware/radio.c **** 
  40:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
  41:../firmware/radio.c ****     if (reg_callbacks[i] == addr) {
  42:../firmware/radio.c ****       reg_callbacks[i] = NULL;
  43:../firmware/radio.c ****       break;
  44:../firmware/radio.c ****     }
  45:../firmware/radio.c ****   }
  46:../firmware/radio.c **** }
  47:../firmware/radio.c **** 
  48:../firmware/radio.c **** static void callbacks_call_all(const uint8_t operation, const uint8_t address)
  49:../firmware/radio.c **** {
  21              		.loc 1 49 0
  22              		.cfi_startproc
  23              		@ Function supports interworking.
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              	.LVL0:
  27 0000 F8402DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, lr}
  28              	.LCFI0:
  29              		.cfi_def_cfa_offset 24
  30              		.cfi_offset 3, -24
  31              		.cfi_offset 4, -20
  32              		.cfi_offset 5, -16
  33              		.cfi_offset 6, -12
  34              		.cfi_offset 7, -8
  35              		.cfi_offset 14, -4
  50:../firmware/radio.c ****   uint8_t i;
  51:../firmware/radio.c **** 
  52:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
  53:../firmware/radio.c ****     if (reg_callbacks[i] != NULL) {
  36              		.loc 1 53 0
  37 0004 38709FE5 		ldr	r7, .L8
  49:../firmware/radio.c **** {
  38              		.loc 1 49 0
  39 0008 0050A0E1 		mov	r5, r0
  40 000c 0160A0E1 		mov	r6, r1
  41 0010 0040A0E3 		mov	r4, #0
  42              	.LVL1:
  43              	.L3:
  44              		.loc 1 53 0
  45 0014 073094E7 		ldr	r3, [r4, r7]
  46 0018 000053E3 		cmp	r3, #0
  54:../firmware/radio.c ****       reg_callbacks[i](operation, address, &regdata2);
  47              		.loc 1 54 0
  48 001c 0500A011 		movne	r0, r5
  49 0020 0610A011 		movne	r1, r6
  50 0024 1C209F15 		ldrne	r2, .L8+4
  51 0028 0FE0A011 		movne	lr, pc
  52 002c 13FF2F11 		bxne	r3
  53              	.LVL2:
  54              	.L2:
  55 0030 044084E2 		add	r4, r4, #4
  52:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
  56              		.loc 1 52 0
  57 0034 400054E3 		cmp	r4, #64
  58 0038 F5FFFF1A 		bne	.L3
  55:../firmware/radio.c ****     }
  56:../firmware/radio.c ****   }
  57:../firmware/radio.c **** }
  59              		.loc 1 57 0
  60 003c F840BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, lr}
  61 0040 1EFF2FE1 		bx	lr
  62              	.L9:
  63              		.align	2
  64              	.L8:
  65 0044 00000000 		.word	.LANCHOR0
  66 0048 40000000 		.word	.LANCHOR0+64
  67              		.cfi_endproc
  68              	.LFE2:
  70              		.align	2
  72              	callbacks_call_one:
  73              	.LFB3:
  58:../firmware/radio.c **** 
  59:../firmware/radio.c **** static uint8_t callbacks_call_one(const uint8_t operation, const uint8_t address)
  60:../firmware/radio.c **** {
  74              		.loc 1 60 0
  75              		.cfi_startproc
  76              		@ Function supports interworking.
  77              		@ args = 0, pretend = 0, frame = 0
  78              		@ frame_needed = 0, uses_anonymous_args = 0
  79              	.LVL3:
  80 004c F8402DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, lr}
  81              	.LCFI1:
  82              		.cfi_def_cfa_offset 24
  83              		.cfi_offset 3, -24
  84              		.cfi_offset 4, -20
  85              		.cfi_offset 5, -16
  86              		.cfi_offset 6, -12
  87              		.cfi_offset 7, -8
  88              		.cfi_offset 14, -4
  61:../firmware/radio.c ****   uint8_t i;
  62:../firmware/radio.c **** 
  63:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
  64:../firmware/radio.c ****     if (reg_callbacks[i] != NULL && reg_callbacks[i](operation, address, &regdata2))
  89              		.loc 1 64 0
  90 0050 50709FE5 		ldr	r7, .L19
  60:../firmware/radio.c **** {
  91              		.loc 1 60 0
  92 0054 0060A0E1 		mov	r6, r0
  93 0058 0150A0E1 		mov	r5, r1
  94 005c 0040A0E3 		mov	r4, #0
  95              	.LVL4:
  96              	.L12:
  97              		.loc 1 64 0
  98 0060 073094E7 		ldr	r3, [r4, r7]
  99 0064 000053E3 		cmp	r3, #0
 100 0068 0400001A 		bne	.L11
 101              	.L14:
 102 006c 044084E2 		add	r4, r4, #4
  63:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
 103              		.loc 1 63 0
 104 0070 400054E3 		cmp	r4, #64
 105 0074 F9FFFF1A 		bne	.L12
  65:../firmware/radio.c ****     return TRUE;
  66:../firmware/radio.c ****   }
  67:../firmware/radio.c ****   return FALSE;
 106              		.loc 1 67 0
 107 0078 0000A0E3 		mov	r0, #0
 108 007c 070000EA 		b	.L13
 109              	.L11:
  64:../firmware/radio.c ****     if (reg_callbacks[i] != NULL && reg_callbacks[i](operation, address, &regdata2))
 110              		.loc 1 64 0 discriminator 1
 111 0080 0600A0E1 		mov	r0, r6
 112 0084 0510A0E1 		mov	r1, r5
 113 0088 1C209FE5 		ldr	r2, .L19+4
 114 008c 0FE0A0E1 		mov	lr, pc
 115 0090 13FF2FE1 		bx	r3
 116              	.LVL5:
 117 0094 000050E3 		cmp	r0, #0
 118 0098 F3FFFF0A 		beq	.L14
  65:../firmware/radio.c ****     return TRUE;
 119              		.loc 1 65 0
 120 009c 0100A0E3 		mov	r0, #1
 121              	.L13:
  68:../firmware/radio.c **** }
 122              		.loc 1 68 0
 123 00a0 F840BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, lr}
 124 00a4 1EFF2FE1 		bx	lr
 125              	.L20:
 126              		.align	2
 127              	.L19:
 128 00a8 00000000 		.word	.LANCHOR0
 129 00ac 40000000 		.word	.LANCHOR0+64
 130              		.cfi_endproc
 131              	.LFE3:
 133              		.align	2
 134              		.global	radio_add_reg_callback
 136              	radio_add_reg_callback:
 137              	.LFB0:
  25:../firmware/radio.c **** {
 138              		.loc 1 25 0
 139              		.cfi_startproc
 140              		@ Function supports interworking.
 141              		@ args = 0, pretend = 0, frame = 0
 142              		@ frame_needed = 0, uses_anonymous_args = 0
 143              		@ link register save eliminated.
 144              	.LVL6:
  29:../firmware/radio.c ****     if (reg_callbacks[i] == NULL) {
 145              		.loc 1 29 0
 146 00b0 28209FE5 		ldr	r2, .L26
  25:../firmware/radio.c **** {
 147              		.loc 1 25 0
 148 00b4 0030A0E3 		mov	r3, #0
 149              	.LVL7:
 150              	.L24:
  29:../firmware/radio.c ****     if (reg_callbacks[i] == NULL) {
 151              		.loc 1 29 0
 152 00b8 031192E7 		ldr	r1, [r2, r3, asl #2]
 153 00bc 000051E3 		cmp	r1, #0
 154 00c0 0200001A 		bne	.L22
  30:../firmware/radio.c ****       reg_callbacks[i] = addr;
 155              		.loc 1 30 0
 156 00c4 14209FE5 		ldr	r2, .L26
 157 00c8 030182E7 		str	r0, [r2, r3, asl #2]
  31:../firmware/radio.c ****       break;
 158              		.loc 1 31 0
 159 00cc 1EFF2FE1 		bx	lr
 160              	.L22:
 161 00d0 013083E2 		add	r3, r3, #1
  28:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
 162              		.loc 1 28 0
 163 00d4 100053E3 		cmp	r3, #16
 164 00d8 F6FFFF1A 		bne	.L24
 165 00dc 1EFF2FE1 		bx	lr
 166              	.L27:
 167              		.align	2
 168              	.L26:
 169 00e0 00000000 		.word	.LANCHOR0
 170              		.cfi_endproc
 171              	.LFE0:
 173              		.align	2
 174              		.global	radio_del_reg_callback
 176              	radio_del_reg_callback:
 177              	.LFB1:
  37:../firmware/radio.c **** {
 178              		.loc 1 37 0
 179              		.cfi_startproc
 180              		@ Function supports interworking.
 181              		@ args = 0, pretend = 0, frame = 0
 182              		@ frame_needed = 0, uses_anonymous_args = 0
 183              		@ link register save eliminated.
 184              	.LVL8:
  41:../firmware/radio.c ****     if (reg_callbacks[i] == addr) {
 185              		.loc 1 41 0
 186 00e4 2C209FE5 		ldr	r2, .L33
  37:../firmware/radio.c **** {
 187              		.loc 1 37 0
 188 00e8 0030A0E3 		mov	r3, #0
 189              	.LVL9:
 190              	.L31:
  41:../firmware/radio.c ****     if (reg_callbacks[i] == addr) {
 191              		.loc 1 41 0
 192 00ec 031192E7 		ldr	r1, [r2, r3, asl #2]
 193 00f0 000051E1 		cmp	r1, r0
 194 00f4 0300001A 		bne	.L29
  42:../firmware/radio.c ****       reg_callbacks[i] = NULL;
 195              		.loc 1 42 0
 196 00f8 18209FE5 		ldr	r2, .L33
 197 00fc 0010A0E3 		mov	r1, #0
 198 0100 031182E7 		str	r1, [r2, r3, asl #2]
  43:../firmware/radio.c ****       break;
 199              		.loc 1 43 0
 200 0104 1EFF2FE1 		bx	lr
 201              	.L29:
 202 0108 013083E2 		add	r3, r3, #1
  40:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
 203              		.loc 1 40 0
 204 010c 100053E3 		cmp	r3, #16
 205 0110 F5FFFF1A 		bne	.L31
 206 0114 1EFF2FE1 		bx	lr
 207              	.L34:
 208              		.align	2
 209              	.L33:
 210 0118 00000000 		.word	.LANCHOR0
 211              		.cfi_endproc
 212              	.LFE1:
 214              		.align	2
 215              		.global	process_UART_in
 217              	process_UART_in:
 218              	.LFB12:
  69:../firmware/radio.c **** 
  70:../firmware/radio.c **** 
  71:../firmware/radio.c **** static void internal_reg_read_8(uint16_t addr)
  72:../firmware/radio.c **** {
  73:../firmware/radio.c ****   if (callbacks_call_one (ROP_READ_8, addr))
  74:../firmware/radio.c ****     return;
  75:../firmware/radio.c **** 
  76:../firmware/radio.c ****   // If the register address is in the static register table, return the
  77:../firmware/radio.c ****   // corresponding table contents. If it is not, return 0xFF.
  78:../firmware/radio.c ****   if (addr < REG8_MAX)
  79:../firmware/radio.c ****     regdata2.byte = reg8_table[addr];
  80:../firmware/radio.c ****   else
  81:../firmware/radio.c ****     regdata2.byte = 0xFF;
  82:../firmware/radio.c **** }
  83:../firmware/radio.c **** 
  84:../firmware/radio.c **** static void internal_reg_read_16(uint16_t addr)
  85:../firmware/radio.c **** {
  86:../firmware/radio.c ****   if (callbacks_call_one (ROP_READ_16, addr))
  87:../firmware/radio.c ****     return;
  88:../firmware/radio.c **** 
  89:../firmware/radio.c ****   // If the register address is in the static register table, return the
  90:../firmware/radio.c ****   // corresponding table contents. If it is not, return 0xFFFF.
  91:../firmware/radio.c ****   if (addr < REG16_MAX)
  92:../firmware/radio.c ****     regdata2.word = reg16_table[addr];
  93:../firmware/radio.c ****   else
  94:../firmware/radio.c ****     regdata2.word = 0xFFFF;
  95:../firmware/radio.c **** }
  96:../firmware/radio.c **** 
  97:../firmware/radio.c **** static void internal_reg_read_32(uint16_t addr)
  98:../firmware/radio.c **** {
  99:../firmware/radio.c ****   if (callbacks_call_one (ROP_READ_32, addr))
 100:../firmware/radio.c ****     return;
 101:../firmware/radio.c **** 
 102:../firmware/radio.c ****   // If the register address is in the static register table, return the
 103:../firmware/radio.c ****   // corresponding table contents. If it is not, return 0xFFFFFFFF.
 104:../firmware/radio.c ****   if (addr < REG32_MAX)
 105:../firmware/radio.c ****     regdata2.dword = reg32_table[addr];
 106:../firmware/radio.c ****   else
 107:../firmware/radio.c ****     regdata2.dword = 0xFFFFFFFF;
 108:../firmware/radio.c **** }
 109:../firmware/radio.c **** 
 110:../firmware/radio.c **** static void internal_reg_read_mb(uint16_t addr)
 111:../firmware/radio.c **** {
 112:../firmware/radio.c ****   regdata2.multibyte.size = 0; // default value
 113:../firmware/radio.c ****   callbacks_call_one (ROP_READ_MB, addr);
 114:../firmware/radio.c **** }
 115:../firmware/radio.c **** 
 116:../firmware/radio.c **** static void internal_reg_write_8(uint16_t addr)
 117:../firmware/radio.c **** {
 118:../firmware/radio.c ****   // If the register address is valid, write the data to it
 119:../firmware/radio.c ****   if (addr < REG8_MAX) {
 120:../firmware/radio.c ****     reg8_table[addr] = regdata2.byte;
 121:../firmware/radio.c ****   }
 122:../firmware/radio.c **** 
 123:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_8, addr);
 124:../firmware/radio.c **** }
 125:../firmware/radio.c **** 
 126:../firmware/radio.c **** static void internal_reg_write_16(uint16_t addr)
 127:../firmware/radio.c **** {
 128:../firmware/radio.c ****   // If the register address is valid, write the data to it
 129:../firmware/radio.c ****   if (addr < REG16_MAX) {
 130:../firmware/radio.c ****     reg16_table[addr] = regdata2.word;
 131:../firmware/radio.c ****   }
 132:../firmware/radio.c **** 
 133:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_16, addr);
 134:../firmware/radio.c **** }
 135:../firmware/radio.c **** 
 136:../firmware/radio.c **** static void internal_reg_write_32(uint16_t addr)
 137:../firmware/radio.c **** {
 138:../firmware/radio.c ****   // If the register address is valid, write the data to it
 139:../firmware/radio.c ****   if (addr < REG32_MAX) {
 140:../firmware/radio.c ****     reg32_table[addr] = regdata2.dword;
 141:../firmware/radio.c ****   }
 142:../firmware/radio.c **** 
 143:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_32, addr);
 144:../firmware/radio.c **** }
 145:../firmware/radio.c **** 
 146:../firmware/radio.c **** static void internal_reg_write_mb(uint16_t addr)
 147:../firmware/radio.c **** {
 148:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_MB, addr);
 149:../firmware/radio.c **** }
 150:../firmware/radio.c **** 
 151:../firmware/radio.c **** void process_UART_in()
 152:../firmware/radio.c **** {
 219              		.loc 1 152 0
 220              		.cfi_startproc
 221              		@ Function supports interworking.
 222              		@ args = 0, pretend = 0, frame = 0
 223              		@ frame_needed = 0, uses_anonymous_args = 0
 224 011c F8452DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
 225              	.LCFI2:
 226              		.cfi_def_cfa_offset 32
 227              		.cfi_offset 3, -32
 228              		.cfi_offset 4, -28
 229              		.cfi_offset 5, -24
 230              		.cfi_offset 6, -20
 231              		.cfi_offset 7, -16
 232              		.cfi_offset 8, -12
 233              		.cfi_offset 10, -8
 234              		.cfi_offset 14, -4
 153:../firmware/radio.c ****   uint8_t b1, b2, i;
 154:../firmware/radio.c ****   uint8_t op, cnt;
 155:../firmware/radio.c ****   uint16_t addr;
 156:../firmware/radio.c ****   uint8_t *input_buffer;
 157:../firmware/radio.c **** 
 158:../firmware/radio.c ****   // Reads the first request bytes
 159:../firmware/radio.c ****   b1 = uart0_waitch();
 235              		.loc 1 159 0
 236 0120 FEFFFFEB 		bl	uart0_waitch
 237              	.LVL10:
 238 0124 0040A0E1 		mov	r4, r0
 239              	.LVL11:
 160:../firmware/radio.c ****   b2 = uart0_waitch();
 240              		.loc 1 160 0
 241 0128 FEFFFFEB 		bl	uart0_waitch
 242              	.LVL12:
 161:../firmware/radio.c **** 
 162:../firmware/radio.c ****   op = (b1 >> 2);
 243              		.loc 1 162 0
 244 012c 24A1A0E1 		mov	sl, r4, lsr #2
 163:../firmware/radio.c ****   addr = ((uint16_t)(b1 & 0x03) << 8) | b2;
 245              		.loc 1 163 0
 246 0130 034004E2 		and	r4, r4, #3
 247              	.LVL13:
 248 0134 040480E1 		orr	r0, r0, r4, asl #8
 249              	.LVL14:
 162:../firmware/radio.c ****   op = (b1 >> 2);
 250              		.loc 1 162 0
 251 0138 FFA00AE2 		and	sl, sl, #255
 252              	.LVL15:
 253              		.loc 1 163 0
 254 013c 0048A0E1 		mov	r4, r0, asl #16
 255 0140 2448A0E1 		mov	r4, r4, lsr #16
 164:../firmware/radio.c **** 
 165:../firmware/radio.c ****   input_buffer = regdata2.bytes;
 166:../firmware/radio.c **** 
 167:../firmware/radio.c ****   // Computes how many bytes we should read
 168:../firmware/radio.c ****   switch (op) {
 256              		.loc 1 168 0
 257 0144 04304AE2 		sub	r3, sl, #4
 163:../firmware/radio.c ****   addr = ((uint16_t)(b1 & 0x03) << 8) | b2;
 258              		.loc 1 163 0
 259 0148 0450A0E1 		mov	r5, r4
 260              	.LVL16:
 261              		.loc 1 168 0
 262 014c 030053E3 		cmp	r3, #3
 263 0150 03F19F97 		ldrls	pc, [pc, r3, asl #2]
 264 0154 0F0000EA 		b	.L36
 265              	.L41:
 266 0158 68010000 		.word	.L37
 267 015c A4010000 		.word	.L62
 268 0160 74010000 		.word	.L39
 269 0164 80010000 		.word	.L40
 270              	.L37:
 165:../firmware/radio.c ****   input_buffer = regdata2.bytes;
 271              		.loc 1 165 0
 272 0168 F4719FE5 		ldr	r7, .L71
 169:../firmware/radio.c ****     case ROP_WRITE_8:
 170:../firmware/radio.c ****       cnt = 1;
 273              		.loc 1 170 0
 274 016c 0160A0E3 		mov	r6, #1
 275 0170 0D0000EA 		b	.L38
 276              	.L39:
 277              	.LVL17:
 165:../firmware/radio.c ****   input_buffer = regdata2.bytes;
 278              		.loc 1 165 0
 279 0174 E8719FE5 		ldr	r7, .L71
 171:../firmware/radio.c ****       break;
 172:../firmware/radio.c ****     case ROP_WRITE_16:
 173:../firmware/radio.c ****       cnt = 2;
 174:../firmware/radio.c ****       break;
 175:../firmware/radio.c ****     case ROP_WRITE_32:
 176:../firmware/radio.c ****       cnt = 4;
 280              		.loc 1 176 0
 281 0178 0460A0E3 		mov	r6, #4
 177:../firmware/radio.c ****       break;
 282              		.loc 1 177 0
 283 017c 0A0000EA 		b	.L38
 284              	.LVL18:
 285              	.L40:
 178:../firmware/radio.c ****     case ROP_WRITE_MB:
 179:../firmware/radio.c ****       cnt = uart0_waitch();
 286              		.loc 1 179 0
 287 0180 FEFFFFEB 		bl	uart0_waitch
 288              	.LVL19:
 180:../firmware/radio.c ****       input_buffer = regdata2.multibyte.data;
 181:../firmware/radio.c ****       regdata2.multibyte.size = cnt;
 289              		.loc 1 181 0
 290 0184 DC719FE5 		ldr	r7, .L71+4
 179:../firmware/radio.c ****       cnt = uart0_waitch();
 291              		.loc 1 179 0
 292 0188 0060A0E1 		mov	r6, r0
 293              	.LVL20:
 294              		.loc 1 181 0
 295 018c 4000C7E5 		strb	r0, [r7, #64]
 180:../firmware/radio.c ****       input_buffer = regdata2.multibyte.data;
 296              		.loc 1 180 0
 297 0190 417087E2 		add	r7, r7, #65
 182:../firmware/radio.c ****       break;
 298              		.loc 1 182 0
 299 0194 040000EA 		b	.L38
 300              	.LVL21:
 301              	.L36:
 165:../firmware/radio.c ****   input_buffer = regdata2.bytes;
 302              		.loc 1 165 0
 303 0198 C4719FE5 		ldr	r7, .L71
 183:../firmware/radio.c ****     default:
 184:../firmware/radio.c ****       cnt = 0;
 304              		.loc 1 184 0
 305 019c 0060A0E3 		mov	r6, #0
 306 01a0 010000EA 		b	.L38
 307              	.LVL22:
 308              	.L62:
 165:../firmware/radio.c ****   input_buffer = regdata2.bytes;
 309              		.loc 1 165 0
 310 01a4 B8719FE5 		ldr	r7, .L71
 173:../firmware/radio.c ****       cnt = 2;
 311              		.loc 1 173 0
 312 01a8 0260A0E3 		mov	r6, #2
 313              	.LVL23:
 314              	.L38:
 185:../firmware/radio.c ****   }
 186:../firmware/radio.c **** 
 187:../firmware/radio.c ****   // Reads the request bytes
 188:../firmware/radio.c ****   for (i = 0; i < cnt; i++)
 315              		.loc 1 188 0
 316 01ac 0080A0E3 		mov	r8, #0
 317 01b0 020000EA 		b	.L42
 318              	.LVL24:
 319              	.L43:
 189:../firmware/radio.c ****     input_buffer[i] = uart0_waitch();
 320              		.loc 1 189 0 discriminator 2
 321 01b4 FEFFFFEB 		bl	uart0_waitch
 322              	.LVL25:
 323 01b8 0800C7E7 		strb	r0, [r7, r8]
 324 01bc 018088E2 		add	r8, r8, #1
 325              	.L42:
 188:../firmware/radio.c ****   for (i = 0; i < cnt; i++)
 326              		.loc 1 188 0 discriminator 1
 327 01c0 FF3008E2 		and	r3, r8, #255
 328 01c4 060053E1 		cmp	r3, r6
 329 01c8 F9FFFF3A 		bcc	.L43
 190:../firmware/radio.c **** 
 191:../firmware/radio.c ****   // Calls the appropriate function
 192:../firmware/radio.c ****   switch (op) {
 330              		.loc 1 192 0
 331 01cc 07005AE3 		cmp	sl, #7
 332 01d0 0AF19F97 		ldrls	pc, [pc, sl, asl #2]
 333 01d4 500000EA 		b	.L63
 334              	.L53:
 335 01d8 F8010000 		.word	.L45
 336 01dc 28020000 		.word	.L46
 337 01e0 58020000 		.word	.L47
 338 01e4 88020000 		.word	.L48
 339 01e8 B0020000 		.word	.L49
 340 01ec D0020000 		.word	.L50
 341 01f0 F0020000 		.word	.L51
 342 01f4 10030000 		.word	.L52
 343              	.L45:
 344              	.LVL26:
 345              	.LBB18:
 346              	.LBB19:
  73:../firmware/radio.c ****   if (callbacks_call_one (ROP_READ_8, addr))
 347              		.loc 1 73 0
 348 01f8 FF1004E2 		and	r1, r4, #255
 349 01fc 0000A0E3 		mov	r0, #0
 350 0200 91FFFFEB 		bl	callbacks_call_one
 351              	.LVL27:
 352 0204 000050E3 		cmp	r0, #0
 353 0208 4500001A 		bne	.L64
  78:../firmware/radio.c ****   if (addr < REG8_MAX)
 354              		.loc 1 78 0
 355 020c 000055E3 		cmp	r5, #0
  79:../firmware/radio.c ****     regdata2.byte = reg8_table[addr];
 356              		.loc 1 79 0
 357 0210 54219F05 		ldreq	r2, .L71+8
 358 0214 4C319FE5 		ldr	r3, .L71+4
 359 0218 0020D205 		ldreqb	r2, [r2, #0]	@ zero_extendqisi2
  81:../firmware/radio.c ****     regdata2.byte = 0xFF;
 360              		.loc 1 81 0
 361 021c 0020E013 		mvnne	r2, #0
 362 0220 4020C3E5 		strb	r2, [r3, #64]
 363 0224 3E0000EA 		b	.L64
 364              	.LVL28:
 365              	.L46:
 366              	.LBE19:
 367              	.LBE18:
 368              	.LBB21:
 369              	.LBB22:
  86:../firmware/radio.c ****   if (callbacks_call_one (ROP_READ_16, addr))
 370              		.loc 1 86 0
 371 0228 FF1004E2 		and	r1, r4, #255
 372 022c 0100A0E3 		mov	r0, #1
 373 0230 85FFFFEB 		bl	callbacks_call_one
 374              	.LVL29:
 375 0234 000050E3 		cmp	r0, #0
 376 0238 3B00001A 		bne	.L65
  91:../firmware/radio.c ****   if (addr < REG16_MAX)
 377              		.loc 1 91 0
 378 023c 000055E3 		cmp	r5, #0
  92:../firmware/radio.c ****     regdata2.word = reg16_table[addr];
 379              		.loc 1 92 0
 380 0240 28219F05 		ldreq	r2, .L71+12
 381 0244 1C319FE5 		ldr	r3, .L71+4
 382 0248 B020D201 		ldreqh	r2, [r2, #0]
  94:../firmware/radio.c ****     regdata2.word = 0xFFFF;
 383              		.loc 1 94 0
 384 024c 0020E013 		mvnne	r2, #0
 385 0250 B024C3E1 		strh	r2, [r3, #64]	@ movhi
 386 0254 340000EA 		b	.L65
 387              	.LVL30:
 388              	.L47:
 389              	.LBE22:
 390              	.LBE21:
 391              	.LBB24:
 392              	.LBB25:
  99:../firmware/radio.c ****   if (callbacks_call_one (ROP_READ_32, addr))
 393              		.loc 1 99 0
 394 0258 FF1004E2 		and	r1, r4, #255
 395 025c 0200A0E3 		mov	r0, #2
 396 0260 79FFFFEB 		bl	callbacks_call_one
 397              	.LVL31:
 398 0264 000050E3 		cmp	r0, #0
 399 0268 3100001A 		bne	.L66
 104:../firmware/radio.c ****   if (addr < REG32_MAX)
 400              		.loc 1 104 0
 401 026c 000055E3 		cmp	r5, #0
 105:../firmware/radio.c ****     regdata2.dword = reg32_table[addr];
 402              		.loc 1 105 0
 403 0270 FC209F05 		ldreq	r2, .L71+16
 404 0274 EC309FE5 		ldr	r3, .L71+4
 405 0278 00209205 		ldreq	r2, [r2, #0]
 107:../firmware/radio.c ****     regdata2.dword = 0xFFFFFFFF;
 406              		.loc 1 107 0
 407 027c 0020E013 		mvnne	r2, #0
 408 0280 402083E5 		str	r2, [r3, #64]
 409 0284 2A0000EA 		b	.L66
 410              	.LVL32:
 411              	.L48:
 412              	.LBE25:
 413              	.LBE24:
 414              	.LBB27:
 415              	.LBB28:
 112:../firmware/radio.c ****   regdata2.multibyte.size = 0; // default value
 416              		.loc 1 112 0
 417 0288 D8509FE5 		ldr	r5, .L71+4
 418 028c 0030A0E3 		mov	r3, #0
 113:../firmware/radio.c ****   callbacks_call_one (ROP_READ_MB, addr);
 419              		.loc 1 113 0
 420 0290 FF1004E2 		and	r1, r4, #255
 421 0294 0300A0E3 		mov	r0, #3
 112:../firmware/radio.c ****   regdata2.multibyte.size = 0; // default value
 422              		.loc 1 112 0
 423 0298 4030C5E5 		strb	r3, [r5, #64]
 113:../firmware/radio.c ****   callbacks_call_one (ROP_READ_MB, addr);
 424              		.loc 1 113 0
 425 029c 6AFFFFEB 		bl	callbacks_call_one
 426              	.LVL33:
 427              	.LBE28:
 428              	.LBE27:
 193:../firmware/radio.c ****     case ROP_READ_8:  // byte read
 194:../firmware/radio.c ****       internal_reg_read_8(addr);
 195:../firmware/radio.c ****       cnt = 1;
 196:../firmware/radio.c ****       break;
 197:../firmware/radio.c ****     case ROP_READ_16:  // word read
 198:../firmware/radio.c ****       internal_reg_read_16(addr);
 199:../firmware/radio.c ****       cnt = 2;
 200:../firmware/radio.c ****       break;
 201:../firmware/radio.c ****     case ROP_READ_32:  // dword read
 202:../firmware/radio.c ****       internal_reg_read_32(addr);
 203:../firmware/radio.c ****       cnt = 4;
 204:../firmware/radio.c ****       break;
 205:../firmware/radio.c ****     case ROP_READ_MB:  // multibyte read
 206:../firmware/radio.c ****       internal_reg_read_mb(addr);
 207:../firmware/radio.c ****       cnt = regdata2.multibyte.size + 1;
 429              		.loc 1 207 0
 430 02a0 4040D5E5 		ldrb	r4, [r5, #64]	@ zero_extendqisi2
 431              	.LVL34:
 432 02a4 014084E2 		add	r4, r4, #1
 433 02a8 FF4004E2 		and	r4, r4, #255
 434              	.LVL35:
 208:../firmware/radio.c ****       break;
 435              		.loc 1 208 0
 436 02ac 210000EA 		b	.L44
 437              	.LVL36:
 438              	.L49:
 439              	.LBB29:
 440              	.LBB30:
 119:../firmware/radio.c ****   if (addr < REG8_MAX) {
 441              		.loc 1 119 0
 442 02b0 000055E3 		cmp	r5, #0
 120:../firmware/radio.c ****     reg8_table[addr] = regdata2.byte;
 443              		.loc 1 120 0
 444 02b4 AC309F05 		ldreq	r3, .L71+4
 445 02b8 4020D305 		ldreqb	r2, [r3, #64]	@ zero_extendqisi2
 446 02bc A8309F05 		ldreq	r3, .L71+8
 123:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_8, addr);
 447              		.loc 1 123 0
 448 02c0 FF1004E2 		and	r1, r4, #255
 120:../firmware/radio.c ****     reg8_table[addr] = regdata2.byte;
 449              		.loc 1 120 0
 450 02c4 0020C305 		streqb	r2, [r3, #0]
 123:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_8, addr);
 451              		.loc 1 123 0
 452 02c8 0400A0E3 		mov	r0, #4
 453 02cc 110000EA 		b	.L67
 454              	.LVL37:
 455              	.L50:
 456              	.LBE30:
 457              	.LBE29:
 458              	.LBB31:
 459              	.LBB32:
 129:../firmware/radio.c ****   if (addr < REG16_MAX) {
 460              		.loc 1 129 0
 461 02d0 000055E3 		cmp	r5, #0
 130:../firmware/radio.c ****     reg16_table[addr] = regdata2.word;
 462              		.loc 1 130 0
 463 02d4 8C309F05 		ldreq	r3, .L71+4
 464 02d8 B024D301 		ldreqh	r2, [r3, #64]
 465 02dc 8C309F05 		ldreq	r3, .L71+12
 133:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_16, addr);
 466              		.loc 1 133 0
 467 02e0 FF1004E2 		and	r1, r4, #255
 130:../firmware/radio.c ****     reg16_table[addr] = regdata2.word;
 468              		.loc 1 130 0
 469 02e4 B020C301 		streqh	r2, [r3, #0]	@ movhi
 133:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_16, addr);
 470              		.loc 1 133 0
 471 02e8 0500A0E3 		mov	r0, #5
 472 02ec 090000EA 		b	.L67
 473              	.LVL38:
 474              	.L51:
 475              	.LBE32:
 476              	.LBE31:
 477              	.LBB33:
 478              	.LBB34:
 139:../firmware/radio.c ****   if (addr < REG32_MAX) {
 479              		.loc 1 139 0
 480 02f0 000055E3 		cmp	r5, #0
 140:../firmware/radio.c ****     reg32_table[addr] = regdata2.dword;
 481              		.loc 1 140 0
 482 02f4 6C309F05 		ldreq	r3, .L71+4
 483 02f8 40209305 		ldreq	r2, [r3, #64]
 484 02fc 70309F05 		ldreq	r3, .L71+16
 143:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_32, addr);
 485              		.loc 1 143 0
 486 0300 FF1004E2 		and	r1, r4, #255
 140:../firmware/radio.c ****     reg32_table[addr] = regdata2.dword;
 487              		.loc 1 140 0
 488 0304 00208305 		streq	r2, [r3, #0]
 143:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_32, addr);
 489              		.loc 1 143 0
 490 0308 0600A0E3 		mov	r0, #6
 491 030c 010000EA 		b	.L67
 492              	.LVL39:
 493              	.L52:
 494              	.LBE34:
 495              	.LBE33:
 496              	.LBB35:
 497              	.LBB36:
 148:../firmware/radio.c ****   callbacks_call_all (ROP_WRITE_MB, addr);
 498              		.loc 1 148 0
 499 0310 FF1004E2 		and	r1, r4, #255
 500 0314 0700A0E3 		mov	r0, #7
 501              	.L67:
 502 0318 38FFFFEB 		bl	callbacks_call_all
 503              	.LVL40:
 504              	.L63:
 505              	.LBE36:
 506              	.LBE35:
 209:../firmware/radio.c ****     case ROP_WRITE_8:  // byte write
 210:../firmware/radio.c ****       internal_reg_write_8(addr);
 211:../firmware/radio.c ****       cnt = 0;
 212:../firmware/radio.c ****       break;
 213:../firmware/radio.c ****     case ROP_WRITE_16:  // word write
 214:../firmware/radio.c ****       internal_reg_write_16(addr);
 215:../firmware/radio.c ****       cnt = 0;
 216:../firmware/radio.c ****       break;
 217:../firmware/radio.c ****     case ROP_WRITE_32:  // dword write
 218:../firmware/radio.c ****       internal_reg_write_32(addr);
 219:../firmware/radio.c ****       cnt = 0;
 220:../firmware/radio.c ****       break;
 221:../firmware/radio.c ****     case ROP_WRITE_MB:  // multibyte write
 222:../firmware/radio.c ****       internal_reg_write_mb(addr);
 223:../firmware/radio.c ****       cnt = 0;
 224:../firmware/radio.c ****       break;
 225:../firmware/radio.c ****     default:
 226:../firmware/radio.c ****       cnt = 0;
 507              		.loc 1 226 0
 508 031c 0040A0E3 		mov	r4, #0
 509              	.LVL41:
 510 0320 040000EA 		b	.L44
 511              	.LVL42:
 512              	.L64:
 513              	.LBB37:
 514              	.LBB20:
 195:../firmware/radio.c ****       cnt = 1;
 515              		.loc 1 195 0
 516 0324 0140A0E3 		mov	r4, #1
 517              	.LVL43:
 518 0328 020000EA 		b	.L44
 519              	.LVL44:
 520              	.L65:
 521              	.LBE20:
 522              	.LBE37:
 523              	.LBB38:
 524              	.LBB23:
 199:../firmware/radio.c ****       cnt = 2;
 525              		.loc 1 199 0
 526 032c 0240A0E3 		mov	r4, #2
 527              	.LVL45:
 528 0330 000000EA 		b	.L44
 529              	.LVL46:
 530              	.L66:
 531              	.LBE23:
 532              	.LBE38:
 533              	.LBB39:
 534              	.LBB26:
 203:../firmware/radio.c ****       cnt = 4;
 535              		.loc 1 203 0
 536 0334 0440A0E3 		mov	r4, #4
 537              	.LVL47:
 538              	.L44:
 539              	.LBE26:
 540              	.LBE39:
 227:../firmware/radio.c ****   }
 228:../firmware/radio.c **** 
 229:../firmware/radio.c ****   // Sends any output bytes
 230:../firmware/radio.c ****   for (i = 0; i < cnt; i++) uart0Putch(regdata2.bytes[i]);
 541              		.loc 1 230 0
 542 0338 0050A0E3 		mov	r5, #0
 543 033c 20609FE5 		ldr	r6, .L71
 544 0340 020000EA 		b	.L60
 545              	.LVL48:
 546              	.L61:
 547              		.loc 1 230 0 is_stmt 0 discriminator 2
 548 0344 0500D6E7 		ldrb	r0, [r6, r5]	@ zero_extendqisi2
 549 0348 FEFFFFEB 		bl	uart0Putch
 550              	.LVL49:
 551 034c 015085E2 		add	r5, r5, #1
 552              	.L60:
 553              		.loc 1 230 0 discriminator 1
 554 0350 FF3005E2 		and	r3, r5, #255
 555 0354 040053E1 		cmp	r3, r4
 556 0358 F9FFFF3A 		bcc	.L61
 231:../firmware/radio.c **** 
 232:../firmware/radio.c **** }
 557              		.loc 1 232 0 is_stmt 1
 558 035c F845BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, r8, sl, lr}
 559 0360 1EFF2FE1 		bx	lr
 560              	.L72:
 561              		.align	2
 562              	.L71:
 563 0364 40000000 		.word	.LANCHOR0+64
 564 0368 00000000 		.word	.LANCHOR0
 565 036c 00000000 		.word	reg8_table
 566 0370 00000000 		.word	reg16_table
 567 0374 00000000 		.word	reg32_table
 568              		.cfi_endproc
 569              	.LFE12:
 571              		.align	2
 572              		.global	radio_init
 574              	radio_init:
 575              	.LFB14:
 233:../firmware/radio.c **** 
 234:../firmware/radio.c **** // UART synchronization with the radio controlling PIC
 235:../firmware/radio.c **** static void sync_radio_pic(void)
 236:../firmware/radio.c **** {
 237:../firmware/radio.c ****   uint8_t i;
 238:../firmware/radio.c ****   do {
 239:../firmware/radio.c ****     i = uart0_waitch();
 240:../firmware/radio.c ****   } while (i!=0xAA);
 241:../firmware/radio.c ****   uart0Putch(0x55);
 242:../firmware/radio.c **** }
 243:../firmware/radio.c **** 
 244:../firmware/radio.c **** void radio_init()
 245:../firmware/radio.c **** {
 576              		.loc 1 245 0
 577              		.cfi_startproc
 578              		@ Function supports interworking.
 579              		@ args = 0, pretend = 0, frame = 0
 580              		@ frame_needed = 0, uses_anonymous_args = 0
 581              	.LVL50:
 582 0378 10402DE9 		stmfd	sp!, {r4, lr}
 583              	.LCFI3:
 584              		.cfi_def_cfa_offset 8
 585              		.cfi_offset 4, -8
 586              		.cfi_offset 14, -4
 587              		.loc 1 245 0
 588 037c 0030A0E3 		mov	r3, #0
 246:../firmware/radio.c ****   uint8_t i;
 247:../firmware/radio.c **** 
 248:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
 249:../firmware/radio.c ****     reg_callbacks[i] = NULL;
 589              		.loc 1 249 0
 590 0380 58209FE5 		ldr	r2, .L78
 591 0384 0310A0E1 		mov	r1, r3
 592              	.LVL51:
 593              	.L74:
 594              		.loc 1 249 0 is_stmt 0 discriminator 2
 595 0388 021083E7 		str	r1, [r3, r2]
 596 038c 043083E2 		add	r3, r3, #4
 248:../firmware/radio.c ****   for (i = 0; i < MAX_REG_CALLBACKS; i++) {
 597              		.loc 1 248 0 is_stmt 1 discriminator 2
 598 0390 400053E3 		cmp	r3, #64
 599 0394 FBFFFF1A 		bne	.L74
 250:../firmware/radio.c ****   }
 251:../firmware/radio.c ****   uart0Init(UART_BAUD(57600), UART_8N1, UART_FIFO_8); // setup the UART
 600              		.loc 1 251 0
 601 0398 8120A0E3 		mov	r2, #129
 602 039c 2100A0E3 		mov	r0, #33
 603 03a0 0310A0E3 		mov	r1, #3
 604 03a4 FEFFFFEB 		bl	uart0Init
 605              	.LVL52:
 252:../firmware/radio.c ****   init_uart0_isr();
 606              		.loc 1 252 0
 607 03a8 FEFFFFEB 		bl	init_uart0_isr
 608              	.LVL53:
 253:../firmware/radio.c ****   IO0SET = LED1_BIT;   // internal LED on
 609              		.loc 1 253 0
 610 03ac 30309FE5 		ldr	r3, .L78+4
 611 03b0 012AA0E3 		mov	r2, #4096
 612 03b4 042083E5 		str	r2, [r3, #4]
 613 03b8 0340A0E1 		mov	r4, r3
 614              	.L75:
 615              	.LBB42:
 616              	.LBB43:
 239:../firmware/radio.c ****     i = uart0_waitch();
 617              		.loc 1 239 0
 618 03bc FEFFFFEB 		bl	uart0_waitch
 619              	.LVL54:
 240:../firmware/radio.c ****   } while (i!=0xAA);
 620              		.loc 1 240 0
 621 03c0 AA0050E3 		cmp	r0, #170
 622 03c4 FCFFFF1A 		bne	.L75
 241:../firmware/radio.c ****   uart0Putch(0x55);
 623              		.loc 1 241 0
 624 03c8 5500A0E3 		mov	r0, #85
 625              	.LVL55:
 626 03cc FEFFFFEB 		bl	uart0Putch
 627              	.LVL56:
 628              	.LBE43:
 629              	.LBE42:
 254:../firmware/radio.c ****   sync_radio_pic();
 255:../firmware/radio.c ****   IO0CLR = LED1_BIT;   // internal LED on
 630              		.loc 1 255 0
 631 03d0 013AA0E3 		mov	r3, #4096
 632 03d4 0C3084E5 		str	r3, [r4, #12]
 256:../firmware/radio.c **** }
 633              		.loc 1 256 0
 634 03d8 1040BDE8 		ldmfd	sp!, {r4, lr}
 635 03dc 1EFF2FE1 		bx	lr
 636              	.L79:
 637              		.align	2
 638              	.L78:
 639 03e0 00000000 		.word	.LANCHOR0
 640 03e4 008002E0 		.word	-536707072
 641              		.cfi_endproc
 642              	.LFE14:
 644              		.comm	reg32_table,4,4
 645              		.comm	reg16_table,2,2
 646              		.comm	reg8_table,1,1
 647              		.bss
 648              		.align	2
 649              		.set	.LANCHOR0,. + 0
 652              	reg_callbacks:
 653 0000 00000000 		.space	64
 653      00000000 
 653      00000000 
 653      00000000 
 653      00000000 
 656              	regdata2:
 657 0040 00000000 		.space	32
 657      00000000 
 657      00000000 
 657      00000000 
 657      00000000 
 658              		.text
 659              	.Letext0:
 660              		.file 2 "c:/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 661              		.file 3 "../firmware/radio.h"
 662              		.file 4 "../../common/regdefs.h"
 663              		.file 5 "../firmware/lpcGPIO.h"
 664              		.file 6 "../firmware/uartISR.h"
 665              		.file 7 "../firmware/uart.h"
DEFINED SYMBOLS
                            *ABS*:00000000 radio.c
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:16     .text:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:18     .text:00000000 callbacks_call_all
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:65     .text:00000044 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:70     .text:0000004c $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:72     .text:0000004c callbacks_call_one
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:128    .text:000000a8 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:133    .text:000000b0 $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:136    .text:000000b0 radio_add_reg_callback
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:169    .text:000000e0 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:173    .text:000000e4 $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:176    .text:000000e4 radio_del_reg_callback
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:210    .text:00000118 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:214    .text:0000011c $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:217    .text:0000011c process_UART_in
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:266    .text:00000158 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:272    .text:00000168 $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:335    .text:000001d8 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:348    .text:000001f8 $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:563    .text:00000364 $d
                            *COM*:00000001 reg8_table
                            *COM*:00000002 reg16_table
                            *COM*:00000004 reg32_table
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:571    .text:00000378 $a
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:574    .text:00000378 radio_init
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:639    .text:000003e0 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:648    .bss:00000000 $d
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:652    .bss:00000000 reg_callbacks
C:\Users\ncmorand\AppData\Local\Temp\ccT50Iuu.s:656    .bss:00000040 regdata2
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
uart0_waitch
uart0Putch
uart0Init
init_uart0_isr
