   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"robot.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	bus_get
  19              	bus_get:
  20              	.LFB0:
  21              		.file 1 "../firmware/robot.c"
   1:../firmware/robot.c **** #include <math.h>
   2:../firmware/robot.c **** #include "config.h"
   3:../firmware/robot.c **** #include "robot.h"
   4:../firmware/robot.c **** #include "registers.h"
   5:../firmware/robot.c **** #include "sysTime.h"
   6:../firmware/robot.c **** #include "module.h"
   7:../firmware/robot.c **** #include "hardware.h"
   8:../firmware/robot.c **** 
   9:../firmware/robot.c **** #ifdef HAS_CAN
  10:../firmware/robot.c **** #include "can.h"
  11:../firmware/robot.c **** #else
  12:../firmware/robot.c **** #include "i2c.h"
  13:../firmware/robot.c **** #endif
  14:../firmware/robot.c **** 
  15:../firmware/robot.c **** #define LIST_END 0xFF
  16:../firmware/robot.c **** 
  17:../firmware/robot.c **** // Device control registers (generic)
  18:../firmware/robot.c **** static const uint8_t gen_regs[][2] = {
  19:../firmware/robot.c ****   { MREG_MODE,             MODE_IDLE },
  20:../firmware/robot.c ****   { MREG_CONTROL_TYPE,     CONTROL_POS },
  21:../firmware/robot.c ****   { MREG_HW_OPTIONS,       HWO_ENC_025 | HWO_INVERT_TORQUE },
  22:../firmware/robot.c ****   { MREG_SW_OPTIONS,       SWO_SEPARATE_D_TERM | SWO_ANTIRESET_WINDUP },
  23:../firmware/robot.c ****   { MREG_SETPOINT_SOURCE,  SETPOINT_SRC_I2C },
  24:../firmware/robot.c ****   { MREG_SETPOINT,         0 },
  25:../firmware/robot.c ****   { MREG_POSITION,         0 },
  26:../firmware/robot.c ****   { MREG_SAMPLE_TIME_H,   16 },
  27:../firmware/robot.c ****   { MREG_SAMPLE_TIME_L,  124 },
  28:../firmware/robot.c ****   { MREG_ERROR_FLAGS,      0 },
  29:../firmware/robot.c ****   { MREG_KD_DIV_POS,       4 },
  30:../firmware/robot.c ****   { MREG_FILTER_POS,       1 },
  31:../firmware/robot.c ****   { MREG_KP_SPEED,        50 },
  32:../firmware/robot.c ****   { MREG_KP_DIV_SPEED,     1 },
  33:../firmware/robot.c ****   { MREG_KI_SPEED,         5 },
  34:../firmware/robot.c ****   { MREG_KI_DIV_SPEED,    10 },
  35:../firmware/robot.c ****   { MREG_KP_TORQUE,       40 },
  36:../firmware/robot.c ****   { MREG_KP_DIV_TORQUE,    5 },
  37:../firmware/robot.c ****   { MREG_KI_TORQUE,       80 },
  38:../firmware/robot.c ****   { MREG_KI_DIV_TORQUE,    8 },
  39:../firmware/robot.c ****   { MREG_DIVIDER_POS,      BODY_POS_DIVIDER },
  40:../firmware/robot.c ****   { MREG_DIVIDER_TORQUE,   2 },
  41:../firmware/robot.c ****   { MREG_KD_POS,          30 },
  42:../firmware/robot.c ****   { MREG_DIVIDER_SPEED,    3 },
  43:../firmware/robot.c ****   { MREG_KP_POS,         100 },
  44:../firmware/robot.c ****   { MREG_KP_DIV_POS,       3 },
  45:../firmware/robot.c ****   { LIST_END,              0 }
  46:../firmware/robot.c **** };
  47:../firmware/robot.c **** 
  48:../firmware/robot.c **** #ifdef HAS_LEGS
  49:../firmware/robot.c **** // Device control registers (leg element specific)
  50:../firmware/robot.c **** static const uint8_t leg_regs[][2] = {
  51:../firmware/robot.c ****   { MREG_SW_OPTIONS,       SWO_ANTIRESET_WINDUP },
  52:../firmware/robot.c ****   { MREG_KD_POS,          40 },
  53:../firmware/robot.c ****   { MREG_DIVIDER_SPEED,    1 },
  54:../firmware/robot.c ****   { MREG_KP_POS,          80 },
  55:../firmware/robot.c ****   { MREG_KP_DIV_POS,       2 },
  56:../firmware/robot.c ****   { MREG_RESET_VALUE,     90 },
  57:../firmware/robot.c ****   { MREG_DIVIDER_POS,      LEGS_POS_DIVIDER },
  58:../firmware/robot.c ****   { LIST_END,              0 }
  59:../firmware/robot.c **** };
  60:../firmware/robot.c **** #endif
  61:../firmware/robot.c **** 
  62:../firmware/robot.c **** uint8_t bus_get(uint8_t module, uint8_t addr)
  63:../firmware/robot.c **** {
  22              		.loc 1 63 0
  23              		.cfi_startproc
  24              		@ Function supports interworking.
  25              		@ args = 0, pretend = 0, frame = 0
  26              		@ frame_needed = 0, uses_anonymous_args = 0
  27              	.LVL0:
  28 0000 08402DE9 		stmfd	sp!, {r3, lr}
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 8
  31              		.cfi_offset 3, -8
  32              		.cfi_offset 14, -4
  64:../firmware/robot.c **** #ifdef HAS_CAN
  65:../firmware/robot.c ****   return get_reg_value_b(module, addr);
  33              		.loc 1 65 0
  34 0004 FEFFFFEB 		bl	get_reg_value_b
  35              	.LVL1:
  66:../firmware/robot.c **** #else
  67:../firmware/robot.c ****   return i2c_get(module, addr);
  68:../firmware/robot.c **** #endif
  69:../firmware/robot.c **** }
  36              		.loc 1 69 0
  37 0008 0840BDE8 		ldmfd	sp!, {r3, lr}
  38 000c 1EFF2FE1 		bx	lr
  39              		.cfi_endproc
  40              	.LFE0:
  42              		.align	2
  43              		.global	bus_set
  45              	bus_set:
  46              	.LFB1:
  70:../firmware/robot.c **** 
  71:../firmware/robot.c **** void bus_set(uint8_t module, uint8_t addr, uint8_t value)
  72:../firmware/robot.c **** {
  47              		.loc 1 72 0
  48              		.cfi_startproc
  49              		@ Function supports interworking.
  50              		@ args = 0, pretend = 0, frame = 0
  51              		@ frame_needed = 0, uses_anonymous_args = 0
  52              	.LVL2:
  53 0010 08402DE9 		stmfd	sp!, {r3, lr}
  54              	.LCFI1:
  55              		.cfi_def_cfa_offset 8
  56              		.cfi_offset 3, -8
  57              		.cfi_offset 14, -4
  73:../firmware/robot.c **** #ifdef HAS_CAN
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
  58              		.loc 1 74 0
  59 0014 FEFFFFEB 		bl	set_reg_value_b
  60              	.LVL3:
  75:../firmware/robot.c **** #else
  76:../firmware/robot.c ****   i2c_set(module, addr, value);
  77:../firmware/robot.c **** #endif
  78:../firmware/robot.c **** }
  61              		.loc 1 78 0
  62 0018 0840BDE8 		ldmfd	sp!, {r3, lr}
  63 001c 1EFF2FE1 		bx	lr
  64              		.cfi_endproc
  65              	.LFE1:
  67              		.align	2
  68              		.global	safe_bus_set
  70              	safe_bus_set:
  71              	.LFB2:
  79:../firmware/robot.c **** 
  80:../firmware/robot.c **** void safe_bus_set(uint8_t module, uint8_t addr, uint8_t value)
  81:../firmware/robot.c **** {
  72              		.loc 1 81 0
  73              		.cfi_startproc
  74              		@ Function supports interworking.
  75              		@ args = 0, pretend = 0, frame = 0
  76              		@ frame_needed = 0, uses_anonymous_args = 0
  77              	.LVL4:
  78 0020 F8402DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, lr}
  79              	.LCFI2:
  80              		.cfi_def_cfa_offset 24
  81              		.cfi_offset 3, -24
  82              		.cfi_offset 4, -20
  83              		.cfi_offset 5, -16
  84              		.cfi_offset 6, -12
  85              		.cfi_offset 7, -8
  86              		.cfi_offset 14, -4
  87              		.loc 1 81 0
  88 0024 0040A0E1 		mov	r4, r0
  89 0028 0150A0E1 		mov	r5, r1
  90 002c 0270A0E1 		mov	r7, r2
  91 0030 0560A0E3 		mov	r6, #5
  92              	.LVL5:
  93              	.L5:
  94              	.LBB26:
  95              	.LBB27:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
  96              		.loc 1 74 0
  97 0034 0510A0E1 		mov	r1, r5
  98 0038 0720A0E1 		mov	r2, r7
  99 003c 0400A0E1 		mov	r0, r4
 100 0040 FEFFFFEB 		bl	set_reg_value_b
 101              	.LVL6:
 102              	.LBE27:
 103              	.LBE26:
 104              	.LBB28:
 105              	.LBB29:
  65:../firmware/robot.c ****   return get_reg_value_b(module, addr);
 106              		.loc 1 65 0
 107 0044 0400A0E1 		mov	r0, r4
 108 0048 0510A0E1 		mov	r1, r5
 109 004c FEFFFFEB 		bl	get_reg_value_b
 110              	.LVL7:
 111              	.LBE29:
 112              	.LBE28:
  82:../firmware/robot.c ****   uint8_t i;
  83:../firmware/robot.c **** 
  84:../firmware/robot.c ****   for (i=0; i<5; i++) {
  85:../firmware/robot.c ****     bus_set(module, addr, value);
  86:../firmware/robot.c ****     if (bus_get(module, addr)==value) break;
 113              		.loc 1 86 0
 114 0050 070050E1 		cmp	r0, r7
 115 0054 0200000A 		beq	.L3
 116 0058 016046E2 		sub	r6, r6, #1
  84:../firmware/robot.c ****   for (i=0; i<5; i++) {
 117              		.loc 1 84 0
 118 005c FF6016E2 		ands	r6, r6, #255
 119 0060 F3FFFF1A 		bne	.L5
 120              	.L3:
  87:../firmware/robot.c ****   }
  88:../firmware/robot.c **** }
 121              		.loc 1 88 0
 122 0064 F840BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, lr}
 123 0068 1EFF2FE1 		bx	lr
 124              		.cfi_endproc
 125              	.LFE2:
 127              		.align	2
 129              	send_config:
 130              	.LFB4:
  89:../firmware/robot.c **** 
  90:../firmware/robot.c **** #ifdef HAS_CAN
  91:../firmware/robot.c **** void safe_bus_setw(uint8_t module, uint8_t addr, uint16_t value)
  92:../firmware/robot.c **** {
  93:../firmware/robot.c ****   uint8_t i;
  94:../firmware/robot.c **** 
  95:../firmware/robot.c ****   for (i=0; i<5; i++) {
  96:../firmware/robot.c ****     set_reg_value_w(module, addr, value);
  97:../firmware/robot.c ****     if (get_reg_value_w(module, addr)==value) break;
  98:../firmware/robot.c ****   }
  99:../firmware/robot.c **** }
 100:../firmware/robot.c **** #endif
 101:../firmware/robot.c **** 
 102:../firmware/robot.c **** // Send standard configuration registers to a single module
 103:../firmware/robot.c **** static void send_config(uint8_t addr)
 104:../firmware/robot.c **** {
 131              		.loc 1 104 0
 132              		.cfi_startproc
 133              		@ Function supports interworking.
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              	.LVL8:
 137 006c 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 138              	.LCFI3:
 139              		.cfi_def_cfa_offset 16
 140              		.cfi_offset 4, -16
 141              		.cfi_offset 5, -12
 142              		.cfi_offset 6, -8
 143              		.cfi_offset 14, -4
 144              		.loc 1 104 0
 145 0070 0060A0E1 		mov	r6, r0
 105:../firmware/robot.c ****   uint8_t idx = 0;
 146              		.loc 1 105 0
 147 0074 0040A0E3 		mov	r4, #0
 106:../firmware/robot.c **** 
 107:../firmware/robot.c ****   while (gen_regs[idx][0] != 0xff) {
 148              		.loc 1 107 0
 149 0078 2C509FE5 		ldr	r5, .L10
 150 007c 050000EA 		b	.L8
 151              	.LVL9:
 152              	.L9:
 108:../firmware/robot.c ****     safe_bus_set(addr, gen_regs[idx][0], gen_regs[idx][1]);
 153              		.loc 1 108 0
 154 0080 843085E0 		add	r3, r5, r4, asl #1
 155 0084 0600A0E1 		mov	r0, r6
 156 0088 0120D3E5 		ldrb	r2, [r3, #1]	@ zero_extendqisi2
 157 008c FEFFFFEB 		bl	safe_bus_set
 158              	.LVL10:
 109:../firmware/robot.c ****     idx++;
 159              		.loc 1 109 0
 160 0090 014084E2 		add	r4, r4, #1
 161              	.LVL11:
 162 0094 FF4004E2 		and	r4, r4, #255
 163              	.LVL12:
 164              	.L8:
 107:../firmware/robot.c ****   while (gen_regs[idx][0] != 0xff) {
 165              		.loc 1 107 0 discriminator 1
 166 0098 8410D5E7 		ldrb	r1, [r5, r4, asl #1]	@ zero_extendqisi2
 167 009c FF0051E3 		cmp	r1, #255
 168 00a0 F6FFFF1A 		bne	.L9
 110:../firmware/robot.c ****   }
 111:../firmware/robot.c **** }
 169              		.loc 1 111 0
 170 00a4 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 171 00a8 1EFF2FE1 		bx	lr
 172              	.L11:
 173              		.align	2
 174              	.L10:
 175 00ac 00000000 		.word	.LANCHOR0
 176              		.cfi_endproc
 177              	.LFE4:
 179              		.align	2
 181              	set_torque_bias:
 182              	.LFB7:
 112:../firmware/robot.c **** 
 113:../firmware/robot.c **** #ifdef HAS_LEGS
 114:../firmware/robot.c **** static void send_config_leg(uint8_t addr)
 115:../firmware/robot.c **** {
 116:../firmware/robot.c ****   uint8_t idx = 0;
 117:../firmware/robot.c **** 
 118:../firmware/robot.c ****   while (leg_regs[idx][0] != 0xff) {
 119:../firmware/robot.c ****     safe_bus_set(addr, leg_regs[idx][0], leg_regs[idx][1]);
 120:../firmware/robot.c ****     idx++;
 121:../firmware/robot.c ****   }
 122:../firmware/robot.c **** }
 123:../firmware/robot.c **** #endif
 124:../firmware/robot.c **** 
 125:../firmware/robot.c **** void start_pid(uint8_t addr)
 126:../firmware/robot.c **** {
 127:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, MODE_IDLE);
 128:../firmware/robot.c ****   safe_bus_set(addr, MREG_CONTROL_TYPE, CONTROL_POS);
 129:../firmware/robot.c ****   safe_bus_set(addr, MREG_POSITION, 0);
 130:../firmware/robot.c ****   safe_bus_set(addr, MREG_SETPOINT, 0);
 131:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, MODE_NORMAL);
 132:../firmware/robot.c **** }
 133:../firmware/robot.c **** 
 134:../firmware/robot.c **** // Zeroes the torque bias (to be used with motor turned off!)
 135:../firmware/robot.c **** static void set_torque_bias(uint8_t addr)
 136:../firmware/robot.c **** {
 183              		.loc 1 136 0
 184              		.cfi_startproc
 185              		@ Function supports interworking.
 186              		@ args = 0, pretend = 0, frame = 0
 187              		@ frame_needed = 0, uses_anonymous_args = 0
 188              	.LVL13:
 189 00b0 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 190              	.LCFI4:
 191              		.cfi_def_cfa_offset 16
 192              		.cfi_offset 4, -16
 193              		.cfi_offset 5, -12
 194              		.cfi_offset 6, -8
 195              		.cfi_offset 14, -4
 137:../firmware/robot.c ****   uint8_t th, tl;
 138:../firmware/robot.c **** 
 139:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, 0);
 196              		.loc 1 139 0
 197 00b4 0020A0E3 		mov	r2, #0
 136:../firmware/robot.c **** {
 198              		.loc 1 136 0
 199 00b8 0040A0E1 		mov	r4, r0
 200              		.loc 1 139 0
 201 00bc 2810A0E3 		mov	r1, #40
 202 00c0 FEFFFFEB 		bl	safe_bus_set
 203              	.LVL14:
 204              	.LBB30:
 205              	.LBB31:
  65:../firmware/robot.c ****   return get_reg_value_b(module, addr);
 206              		.loc 1 65 0
 207 00c4 0400A0E1 		mov	r0, r4
 208 00c8 3C10A0E3 		mov	r1, #60
 209 00cc FEFFFFEB 		bl	get_reg_value_b
 210              	.LVL15:
 211              	.LBE31:
 212              	.LBE30:
 213              	.LBB33:
 214              	.LBB34:
 215 00d0 3D10A0E3 		mov	r1, #61
 216              	.LBE34:
 217              	.LBE33:
 218              	.LBB37:
 219              	.LBB32:
 220 00d4 0060A0E1 		mov	r6, r0
 221              	.LVL16:
 222              	.LBE32:
 223              	.LBE37:
 224              	.LBB38:
 225              	.LBB35:
 226 00d8 0400A0E1 		mov	r0, r4
 227 00dc FEFFFFEB 		bl	get_reg_value_b
 228              	.LVL17:
 229              	.LBE35:
 230              	.LBE38:
 231              	.LBB39:
 232              	.LBB40:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 233              		.loc 1 74 0
 234 00e0 0620A0E1 		mov	r2, r6
 235              	.LBE40:
 236              	.LBE39:
 237              	.LBB42:
 238              	.LBB36:
  65:../firmware/robot.c ****   return get_reg_value_b(module, addr);
 239              		.loc 1 65 0
 240 00e4 0050A0E1 		mov	r5, r0
 241              	.LVL18:
 242              	.LBE36:
 243              	.LBE42:
 244              	.LBB43:
 245              	.LBB41:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 246              		.loc 1 74 0
 247 00e8 3E10A0E3 		mov	r1, #62
 248 00ec 0400A0E1 		mov	r0, r4
 249 00f0 FEFFFFEB 		bl	set_reg_value_b
 250              	.LVL19:
 251              	.LBE41:
 252              	.LBE43:
 253              	.LBB44:
 254              	.LBB45:
 255 00f4 0520A0E1 		mov	r2, r5
 256 00f8 0400A0E1 		mov	r0, r4
 257 00fc 3F10A0E3 		mov	r1, #63
 258 0100 FEFFFFEB 		bl	set_reg_value_b
 259              	.LVL20:
 260              	.LBE45:
 261              	.LBE44:
 262              	.LBB46:
 263              	.LBB47:
 264 0104 0400A0E1 		mov	r0, r4
 265 0108 2D10A0E3 		mov	r1, #45
 266 010c 0020A0E3 		mov	r2, #0
 267 0110 FEFFFFEB 		bl	set_reg_value_b
 268              	.LVL21:
 269              	.LBE47:
 270              	.LBE46:
 140:../firmware/robot.c ****   th = bus_get(addr, MREG_TORQUE_H);
 141:../firmware/robot.c ****   tl = bus_get(addr, MREG_TORQUE_L);
 142:../firmware/robot.c ****   bus_set(addr, MREG_TORQUE_BIAS_H, th);
 143:../firmware/robot.c ****   bus_set(addr, MREG_TORQUE_BIAS_L, tl);
 144:../firmware/robot.c ****   bus_set(addr, MREG_ERROR_FLAGS, 0);
 145:../firmware/robot.c **** }
 271              		.loc 1 145 0
 272 0114 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 273 0118 1EFF2FE1 		bx	lr
 274              		.cfi_endproc
 275              	.LFE7:
 277              		.align	2
 278              		.global	safe_bus_setw
 280              	safe_bus_setw:
 281              	.LFB3:
  92:../firmware/robot.c **** {
 282              		.loc 1 92 0
 283              		.cfi_startproc
 284              		@ Function supports interworking.
 285              		@ args = 0, pretend = 0, frame = 0
 286              		@ frame_needed = 0, uses_anonymous_args = 0
 287              	.LVL22:
 288 011c F8402DE9 		stmfd	sp!, {r3, r4, r5, r6, r7, lr}
 289              	.LCFI5:
 290              		.cfi_def_cfa_offset 24
 291              		.cfi_offset 3, -24
 292              		.cfi_offset 4, -20
 293              		.cfi_offset 5, -16
 294              		.cfi_offset 6, -12
 295              		.cfi_offset 7, -8
 296              		.cfi_offset 14, -4
  92:../firmware/robot.c **** {
 297              		.loc 1 92 0
 298 0120 0040A0E1 		mov	r4, r0
 299 0124 0150A0E1 		mov	r5, r1
 300 0128 0270A0E1 		mov	r7, r2
 301 012c 0560A0E3 		mov	r6, #5
 302              	.LVL23:
 303              	.L15:
  96:../firmware/robot.c ****     set_reg_value_w(module, addr, value);
 304              		.loc 1 96 0
 305 0130 0510A0E1 		mov	r1, r5
 306 0134 0720A0E1 		mov	r2, r7
 307 0138 0400A0E1 		mov	r0, r4
 308 013c FEFFFFEB 		bl	set_reg_value_w
 309              	.LVL24:
  97:../firmware/robot.c ****     if (get_reg_value_w(module, addr)==value) break;
 310              		.loc 1 97 0
 311 0140 0400A0E1 		mov	r0, r4
 312 0144 0510A0E1 		mov	r1, r5
 313 0148 FEFFFFEB 		bl	get_reg_value_w
 314              	.LVL25:
 315 014c 070050E1 		cmp	r0, r7
 316 0150 0200000A 		beq	.L13
 317 0154 016046E2 		sub	r6, r6, #1
  95:../firmware/robot.c ****   for (i=0; i<5; i++) {
 318              		.loc 1 95 0
 319 0158 FF6016E2 		ands	r6, r6, #255
 320 015c F3FFFF1A 		bne	.L15
 321              	.L13:
  99:../firmware/robot.c **** }
 322              		.loc 1 99 0
 323 0160 F840BDE8 		ldmfd	sp!, {r3, r4, r5, r6, r7, lr}
 324 0164 1EFF2FE1 		bx	lr
 325              		.cfi_endproc
 326              	.LFE3:
 328              		.align	2
 329              		.global	start_pid
 331              	start_pid:
 332              	.LFB6:
 126:../firmware/robot.c **** {
 333              		.loc 1 126 0
 334              		.cfi_startproc
 335              		@ Function supports interworking.
 336              		@ args = 0, pretend = 0, frame = 0
 337              		@ frame_needed = 0, uses_anonymous_args = 0
 338              	.LVL26:
 339 0168 10402DE9 		stmfd	sp!, {r4, lr}
 340              	.LCFI6:
 341              		.cfi_def_cfa_offset 8
 342              		.cfi_offset 4, -8
 343              		.cfi_offset 14, -4
 127:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, MODE_IDLE);
 344              		.loc 1 127 0
 345 016c 2810A0E3 		mov	r1, #40
 126:../firmware/robot.c **** {
 346              		.loc 1 126 0
 347 0170 0040A0E1 		mov	r4, r0
 127:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, MODE_IDLE);
 348              		.loc 1 127 0
 349 0174 0020A0E3 		mov	r2, #0
 350 0178 FEFFFFEB 		bl	safe_bus_set
 351              	.LVL27:
 128:../firmware/robot.c ****   safe_bus_set(addr, MREG_CONTROL_TYPE, CONTROL_POS);
 352              		.loc 1 128 0
 353 017c 0400A0E1 		mov	r0, r4
 354 0180 2C10A0E3 		mov	r1, #44
 355 0184 0120A0E3 		mov	r2, #1
 356 0188 FEFFFFEB 		bl	safe_bus_set
 357              	.LVL28:
 129:../firmware/robot.c ****   safe_bus_set(addr, MREG_POSITION, 0);
 358              		.loc 1 129 0
 359 018c 0400A0E1 		mov	r0, r4
 360 0190 3010A0E3 		mov	r1, #48
 361 0194 0020A0E3 		mov	r2, #0
 362 0198 FEFFFFEB 		bl	safe_bus_set
 363              	.LVL29:
 130:../firmware/robot.c ****   safe_bus_set(addr, MREG_SETPOINT, 0);
 364              		.loc 1 130 0
 365 019c 0400A0E1 		mov	r0, r4
 366 01a0 2F10A0E3 		mov	r1, #47
 367 01a4 0020A0E3 		mov	r2, #0
 368 01a8 FEFFFFEB 		bl	safe_bus_set
 369              	.LVL30:
 131:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, MODE_NORMAL);
 370              		.loc 1 131 0
 371 01ac 0400A0E1 		mov	r0, r4
 372 01b0 2810A0E3 		mov	r1, #40
 373 01b4 0120A0E3 		mov	r2, #1
 132:../firmware/robot.c **** }
 374              		.loc 1 132 0
 375 01b8 1040BDE8 		ldmfd	sp!, {r4, lr}
 131:../firmware/robot.c ****   safe_bus_set(addr, MREG_MODE, MODE_NORMAL);
 376              		.loc 1 131 0
 377 01bc FEFFFFEA 		b	safe_bus_set
 378              	.LVL31:
 379              		.cfi_endproc
 380              	.LFE6:
 382              		.align	2
 383              		.global	reset_pos
 385              	reset_pos:
 386              	.LFB8:
 146:../firmware/robot.c **** 
 147:../firmware/robot.c **** #ifdef HAS_LEGS
 148:../firmware/robot.c **** void reset_pos(uint8_t el)
 149:../firmware/robot.c **** {
 387              		.loc 1 149 0
 388              		.cfi_startproc
 389              		@ Function supports interworking.
 390              		@ args = 0, pretend = 0, frame = 0
 391              		@ frame_needed = 0, uses_anonymous_args = 0
 392              	.LVL32:
 393 01c0 10402DE9 		stmfd	sp!, {r4, lr}
 394              	.LCFI7:
 395              		.cfi_def_cfa_offset 8
 396              		.cfi_offset 4, -8
 397              		.cfi_offset 14, -4
 398              	.LBB48:
 399              	.LBB49:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 400              		.loc 1 74 0
 401 01c4 2810A0E3 		mov	r1, #40
 402 01c8 0620A0E3 		mov	r2, #6
 403              	.LBE49:
 404              	.LBE48:
 405              		.loc 1 149 0
 406 01cc 0040A0E1 		mov	r4, r0
 407              	.LVL33:
 408              	.LBB51:
 409              	.LBB50:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 410              		.loc 1 74 0
 411 01d0 FEFFFFEB 		bl	set_reg_value_b
 412              	.LVL34:
 413              	.L19:
 414              	.LBE50:
 415              	.LBE51:
 416              	.LBB52:
 417              	.LBB53:
  65:../firmware/robot.c ****   return get_reg_value_b(module, addr);
 418              		.loc 1 65 0 discriminator 1
 419 01d4 0400A0E1 		mov	r0, r4
 420 01d8 2810A0E3 		mov	r1, #40
 421 01dc FEFFFFEB 		bl	get_reg_value_b
 422              	.LVL35:
 423              	.LBE53:
 424              	.LBE52:
 150:../firmware/robot.c ****   bus_set(el, MREG_MODE, MODE_SETPOINT_RESET);
 151:../firmware/robot.c ****   while (bus_get(el, MREG_MODE)==MODE_SETPOINT_RESET);
 425              		.loc 1 151 0 discriminator 1
 426 01e0 060050E3 		cmp	r0, #6
 427 01e4 FAFFFF0A 		beq	.L19
 152:../firmware/robot.c **** }
 428              		.loc 1 152 0
 429 01e8 1040BDE8 		ldmfd	sp!, {r4, lr}
 430 01ec 1EFF2FE1 		bx	lr
 431              		.cfi_endproc
 432              	.LFE8:
 434              		.align	2
 435              		.global	set_leg_setpoint
 437              	set_leg_setpoint:
 438              	.LFB9:
 153:../firmware/robot.c **** 
 154:../firmware/robot.c **** void set_leg_setpoint(uint8_t addr, int8_t pos)
 155:../firmware/robot.c **** {
 439              		.loc 1 155 0
 440              		.cfi_startproc
 441              		@ Function supports interworking.
 442              		@ args = 0, pretend = 0, frame = 0
 443              		@ frame_needed = 0, uses_anonymous_args = 0
 444              	.LVL36:
 156:../firmware/robot.c ****   if ((addr & 1)) pos = -pos;
 445              		.loc 1 156 0
 446 01f0 010010E3 		tst	r0, #1
 447 01f4 00106112 		rsbne	r1, r1, #0
 448              	.LVL37:
 449 01f8 011CA011 		movne	r1, r1, asl #24
 450 01fc 411CA011 		movne	r1, r1, asr #24
 451              	.LVL38:
 452              	.LBB54:
 453              	.LBB55:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 454              		.loc 1 74 0
 455 0200 FF2001E2 		and	r2, r1, #255
 456              	.LBE55:
 457              	.LBE54:
 155:../firmware/robot.c **** {
 458              		.loc 1 155 0
 459 0204 08402DE9 		stmfd	sp!, {r3, lr}
 460              	.LCFI8:
 461              		.cfi_def_cfa_offset 8
 462              		.cfi_offset 3, -8
 463              		.cfi_offset 14, -4
 464              	.LBB57:
 465              	.LBB56:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 466              		.loc 1 74 0
 467 0208 2F10A0E3 		mov	r1, #47
 468              	.LVL39:
 469 020c FEFFFFEB 		bl	set_reg_value_b
 470              	.LVL40:
 471              	.LBE56:
 472              	.LBE57:
 157:../firmware/robot.c ****   bus_set(addr, MREG_SETPOINT, pos);
 158:../firmware/robot.c **** }
 473              		.loc 1 158 0
 474 0210 0840BDE8 		ldmfd	sp!, {r3, lr}
 475 0214 1EFF2FE1 		bx	lr
 476              		.cfi_endproc
 477              	.LFE9:
 479              		.align	2
 480              		.global	init_body_module
 482              	init_body_module:
 483              	.LFB10:
 159:../firmware/robot.c **** #endif
 160:../firmware/robot.c **** 
 161:../firmware/robot.c **** void init_body_module(uint8_t addr)
 162:../firmware/robot.c **** {
 484              		.loc 1 162 0
 485              		.cfi_startproc
 486              		@ Function supports interworking.
 487              		@ args = 0, pretend = 0, frame = 0
 488              		@ frame_needed = 0, uses_anonymous_args = 0
 489              	.LVL41:
 490 0218 38402DE9 		stmfd	sp!, {r3, r4, r5, lr}
 491              	.LCFI9:
 492              		.cfi_def_cfa_offset 16
 493              		.cfi_offset 3, -16
 494              		.cfi_offset 4, -12
 495              		.cfi_offset 5, -8
 496              		.cfi_offset 14, -4
 497              		.loc 1 162 0
 498 021c 0050A0E1 		mov	r5, r0
 163:../firmware/robot.c ****   uint8_t j;
 164:../firmware/robot.c **** 
 165:../firmware/robot.c ****   // Clears all the registers to make sure we don't have strange defaults inside
 166:../firmware/robot.c ****   for (j = 40; j < 100; j++) {
 499              		.loc 1 166 0
 500 0220 2840A0E3 		mov	r4, #40
 501              	.LVL42:
 502              	.L30:
 503              	.LBB58:
 504              	.LBB59:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 505              		.loc 1 74 0
 506 0224 0410A0E1 		mov	r1, r4
 507              	.LBE59:
 508              	.LBE58:
 509              		.loc 1 166 0
 510 0228 014084E2 		add	r4, r4, #1
 511              	.LVL43:
 512              	.LBB62:
 513              	.LBB60:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 514              		.loc 1 74 0
 515 022c 0500A0E1 		mov	r0, r5
 516 0230 0020A0E3 		mov	r2, #0
 517              	.LBE60:
 518              	.LBE62:
 519              		.loc 1 166 0
 520 0234 FF4004E2 		and	r4, r4, #255
 521              	.LBB63:
 522              	.LBB61:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 523              		.loc 1 74 0
 524 0238 FEFFFFEB 		bl	set_reg_value_b
 525              	.LVL44:
 526              	.LBE61:
 527              	.LBE63:
 528              		.loc 1 166 0
 529 023c 640054E3 		cmp	r4, #100
 530 0240 F7FFFF1A 		bne	.L30
 167:../firmware/robot.c ****     bus_set(addr, j, 0);
 168:../firmware/robot.c ****   }
 169:../firmware/robot.c ****   send_config(addr);
 531              		.loc 1 169 0
 532 0244 0500A0E1 		mov	r0, r5
 533 0248 87FFFFEB 		bl	send_config
 534              	.LVL45:
 170:../firmware/robot.c ****   set_torque_bias(addr);
 535              		.loc 1 170 0
 536 024c 0500A0E1 		mov	r0, r5
 171:../firmware/robot.c **** }
 537              		.loc 1 171 0
 538 0250 3840BDE8 		ldmfd	sp!, {r3, r4, r5, lr}
 170:../firmware/robot.c ****   set_torque_bias(addr);
 539              		.loc 1 170 0
 540 0254 95FFFFEA 		b	set_torque_bias
 541              	.LVL46:
 542              		.cfi_endproc
 543              	.LFE10:
 545              		.align	2
 546              		.global	init_limb_module
 548              	init_limb_module:
 549              	.LFB11:
 172:../firmware/robot.c **** 
 173:../firmware/robot.c **** #ifdef HAS_LEGS
 174:../firmware/robot.c **** void init_limb_module(uint8_t addr)
 175:../firmware/robot.c **** {
 550              		.loc 1 175 0
 551              		.cfi_startproc
 552              		@ Function supports interworking.
 553              		@ args = 0, pretend = 0, frame = 0
 554              		@ frame_needed = 0, uses_anonymous_args = 0
 555              	.LVL47:
 556 0258 70402DE9 		stmfd	sp!, {r4, r5, r6, lr}
 557              	.LCFI10:
 558              		.cfi_def_cfa_offset 16
 559              		.cfi_offset 4, -16
 560              		.cfi_offset 5, -12
 561              		.cfi_offset 6, -8
 562              		.cfi_offset 14, -4
 563              		.loc 1 175 0
 564 025c 0040A0E1 		mov	r4, r0
 176:../firmware/robot.c ****   uint8_t j;
 177:../firmware/robot.c **** 
 178:../firmware/robot.c ****   // Clears all the registers
 179:../firmware/robot.c ****   for (j = 40; j < 100; j++) {
 565              		.loc 1 179 0
 566 0260 2850A0E3 		mov	r5, #40
 567              	.LVL48:
 568              	.L33:
 569              	.LBB68:
 570              	.LBB69:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 571              		.loc 1 74 0
 572 0264 0510A0E1 		mov	r1, r5
 573              	.LBE69:
 574              	.LBE68:
 575              		.loc 1 179 0
 576 0268 015085E2 		add	r5, r5, #1
 577              	.LVL49:
 578              	.LBB72:
 579              	.LBB70:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 580              		.loc 1 74 0
 581 026c 0400A0E1 		mov	r0, r4
 582 0270 0020A0E3 		mov	r2, #0
 583              	.LBE70:
 584              	.LBE72:
 585              		.loc 1 179 0
 586 0274 FF5005E2 		and	r5, r5, #255
 587              	.LBB73:
 588              	.LBB71:
  74:../firmware/robot.c ****   set_reg_value_b(module, addr, value);
 589              		.loc 1 74 0
 590 0278 FEFFFFEB 		bl	set_reg_value_b
 591              	.LVL50:
 592              	.LBE71:
 593              	.LBE73:
 594              		.loc 1 179 0
 595 027c 640055E3 		cmp	r5, #100
 596 0280 F7FFFF1A 		bne	.L33
 180:../firmware/robot.c ****     bus_set(addr, j, 0);
 181:../firmware/robot.c ****   }
 182:../firmware/robot.c ****   send_config(addr);
 597              		.loc 1 182 0
 598 0284 0400A0E1 		mov	r0, r4
 599 0288 77FFFFEB 		bl	send_config
 600              	.LVL51:
 116:../firmware/robot.c ****   uint8_t idx = 0;
 601              		.loc 1 116 0
 602 028c 0050A0E3 		mov	r5, #0
 603              	.LVL52:
 604              	.LBB74:
 605              	.LBB75:
 118:../firmware/robot.c ****   while (leg_regs[idx][0] != 0xff) {
 606              		.loc 1 118 0
 607 0290 2C609FE5 		ldr	r6, .L37
 608 0294 030000EA 		b	.L34
 609              	.LVL53:
 610              	.L35:
 119:../firmware/robot.c ****     safe_bus_set(addr, leg_regs[idx][0], leg_regs[idx][1]);
 611              		.loc 1 119 0
 612 0298 3720D3E5 		ldrb	r2, [r3, #55]	@ zero_extendqisi2
 613 029c FEFFFFEB 		bl	safe_bus_set
 614              	.LVL54:
 120:../firmware/robot.c ****     idx++;
 615              		.loc 1 120 0
 616 02a0 015085E2 		add	r5, r5, #1
 617              	.LVL55:
 618 02a4 FF5005E2 		and	r5, r5, #255
 619              	.LVL56:
 620              	.L34:
 118:../firmware/robot.c ****   while (leg_regs[idx][0] != 0xff) {
 621              		.loc 1 118 0
 622 02a8 853086E0 		add	r3, r6, r5, asl #1
 623 02ac 3610D3E5 		ldrb	r1, [r3, #54]	@ zero_extendqisi2
 624 02b0 FF0051E3 		cmp	r1, #255
 119:../firmware/robot.c ****     safe_bus_set(addr, leg_regs[idx][0], leg_regs[idx][1]);
 625              		.loc 1 119 0
 626 02b4 0400A0E1 		mov	r0, r4
 118:../firmware/robot.c ****   while (leg_regs[idx][0] != 0xff) {
 627              		.loc 1 118 0
 628 02b8 F6FFFF1A 		bne	.L35
 629              	.LVL57:
 630              	.LBE75:
 631              	.LBE74:
 183:../firmware/robot.c ****   send_config_leg(addr);
 184:../firmware/robot.c ****   set_torque_bias(addr);
 185:../firmware/robot.c **** }
 632              		.loc 1 185 0
 633 02bc 7040BDE8 		ldmfd	sp!, {r4, r5, r6, lr}
 184:../firmware/robot.c ****   set_torque_bias(addr);
 634              		.loc 1 184 0
 635 02c0 7AFFFFEA 		b	set_torque_bias
 636              	.LVL58:
 637              	.L38:
 638              		.align	2
 639              	.L37:
 640 02c4 00000000 		.word	.LANCHOR0
 641              		.cfi_endproc
 642              	.LFE11:
 644              		.section	.rodata
 645              		.set	.LANCHOR0,. + 0
 648              	gen_regs:
 649 0000 28       		.byte	40
 650 0001 00       		.byte	0
 651 0002 2C       		.byte	44
 652 0003 01       		.byte	1
 653 0004 2A       		.byte	42
 654 0005 18       		.byte	24
 655 0006 2B       		.byte	43
 656 0007 03       		.byte	3
 657 0008 29       		.byte	41
 658 0009 00       		.byte	0
 659 000a 2F       		.byte	47
 660 000b 00       		.byte	0
 661 000c 30       		.byte	48
 662 000d 00       		.byte	0
 663 000e 4D       		.byte	77
 664 000f 10       		.byte	16
 665 0010 4E       		.byte	78
 666 0011 7C       		.byte	124
 667 0012 2D       		.byte	45
 668 0013 00       		.byte	0
 669 0014 43       		.byte	67
 670 0015 04       		.byte	4
 671 0016 44       		.byte	68
 672 0017 01       		.byte	1
 673 0018 45       		.byte	69
 674 0019 32       		.byte	50
 675 001a 46       		.byte	70
 676 001b 01       		.byte	1
 677 001c 47       		.byte	71
 678 001d 05       		.byte	5
 679 001e 48       		.byte	72
 680 001f 0A       		.byte	10
 681 0020 49       		.byte	73
 682 0021 28       		.byte	40
 683 0022 4A       		.byte	74
 684 0023 05       		.byte	5
 685 0024 4B       		.byte	75
 686 0025 50       		.byte	80
 687 0026 4C       		.byte	76
 688 0027 08       		.byte	8
 689 0028 33       		.byte	51
 690 0029 07       		.byte	7
 691 002a 3B       		.byte	59
 692 002b 02       		.byte	2
 693 002c 42       		.byte	66
 694 002d 1E       		.byte	30
 695 002e 38       		.byte	56
 696 002f 03       		.byte	3
 697 0030 40       		.byte	64
 698 0031 64       		.byte	100
 699 0032 41       		.byte	65
 700 0033 03       		.byte	3
 701 0034 FF       		.byte	-1
 702 0035 00       		.byte	0
 705              	leg_regs:
 706 0036 2B       		.byte	43
 707 0037 02       		.byte	2
 708 0038 42       		.byte	66
 709 0039 28       		.byte	40
 710 003a 38       		.byte	56
 711 003b 01       		.byte	1
 712 003c 40       		.byte	64
 713 003d 50       		.byte	80
 714 003e 41       		.byte	65
 715 003f 02       		.byte	2
 716 0040 63       		.byte	99
 717 0041 5A       		.byte	90
 718 0042 33       		.byte	51
 719 0043 08       		.byte	8
 720 0044 FF       		.byte	-1
 721 0045 00       		.byte	0
 722              		.text
 723              	.Letext0:
 724              		.file 2 "c:/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 725              		.file 3 "../firmware/can.h"
DEFINED SYMBOLS
                            *ABS*:00000000 robot.c
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:16     .text:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:19     .text:00000000 bus_get
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:45     .text:00000010 bus_set
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:70     .text:00000020 safe_bus_set
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:129    .text:0000006c send_config
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:175    .text:000000ac $d
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:179    .text:000000b0 $a
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:181    .text:000000b0 set_torque_bias
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:280    .text:0000011c safe_bus_setw
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:331    .text:00000168 start_pid
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:385    .text:000001c0 reset_pos
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:437    .text:000001f0 set_leg_setpoint
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:482    .text:00000218 init_body_module
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:548    .text:00000258 init_limb_module
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:640    .text:000002c4 $d
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:648    .rodata:00000000 gen_regs
C:\Users\ncmorand\AppData\Local\Temp\ccmNTYHJ.s:705    .rodata:00000036 leg_regs
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
get_reg_value_b
set_reg_value_b
set_reg_value_w
get_reg_value_w
