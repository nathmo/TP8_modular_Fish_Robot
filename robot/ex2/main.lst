   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"main.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  18              	register_handler:
  19              	.LFB0:
  20              		.file 1 "main.c"
   1:main.c        **** #include "hardware.h"
   2:main.c        **** #include "registers.h"
   3:main.c        **** 
   4:main.c        **** static uint32_t datavar = 0;
   5:main.c        **** static uint8_t last_mb_size = 0;
   6:main.c        **** static uint8_t counter = 0;
   7:main.c        **** static uint8_t mb_buffer[MAX_MB_SIZE];
   8:main.c        **** 
   9:main.c        **** /* Register callback function, handles some new registers on the radio.
  10:main.c        ****  * All these registers are of course completely useless, but it demonstrates how
  11:main.c        ****  * to implement a register callback function, and what it can do.
  12:main.c        ****  */
  13:main.c        **** static int8_t register_handler(uint8_t operation, uint8_t address, RadioData* radio_data)
  14:main.c        **** {
  21              		.loc 1 14 0
  22              		.cfi_startproc
  23              		@ Function supports interworking.
  24              		@ args = 0, pretend = 0, frame = 0
  25              		@ frame_needed = 0, uses_anonymous_args = 0
  26              		@ link register save eliminated.
  27              	.LVL0:
  28 0000 04402DE5 		str	r4, [sp, #-4]!
  29              	.LCFI0:
  30              		.cfi_def_cfa_offset 4
  31              		.cfi_offset 4, -4
  15:main.c        ****   uint8_t i;
  16:main.c        ****   
  17:main.c        ****   switch (operation)
  32              		.loc 1 17 0
  33 0004 070050E3 		cmp	r0, #7
  34 0008 00F19F97 		ldrls	pc, [pc, r0, asl #2]
  35 000c 500000EA 		b	.L21
  36              	.L9:
  37 0010 30000000 		.word	.L3
  38 0014 54010000 		.word	.L21
  39 0018 78000000 		.word	.L4
  40 001c 90000000 		.word	.L5
  41 0020 D0000000 		.word	.L6
  42 0024 EC000000 		.word	.L7
  43 0028 54010000 		.word	.L21
  44 002c 10010000 		.word	.L8
  45              	.L3:
  18:main.c        ****   {
  19:main.c        ****     case ROP_READ_8:
  20:main.c        ****       if (address == 6) {
  46              		.loc 1 20 0
  47 0030 060051E3 		cmp	r1, #6
  48 0034 0500001A 		bne	.L10
  21:main.c        ****         radio_data->byte = counter;
  49              		.loc 1 21 0
  50 0038 20319FE5 		ldr	r3, .L23
  51 003c 0010D3E5 		ldrb	r1, [r3, #0]	@ zero_extendqisi2
  52              	.LVL1:
  53 0040 0010C2E5 		strb	r1, [r2, #0]
  22:main.c        ****         counter = 0;
  54              		.loc 1 22 0
  55 0044 0020A0E3 		mov	r2, #0
  56              	.LVL2:
  57 0048 0020C3E5 		strb	r2, [r3, #0]
  58 004c 070000EA 		b	.L22
  59              	.LVL3:
  60              	.L10:
  23:main.c        ****         return TRUE;
  24:main.c        ****       } else if (address == 21) {
  61              		.loc 1 24 0
  62 0050 150051E3 		cmp	r1, #21
  63 0054 3E00001A 		bne	.L21
  25:main.c        ****         counter++;
  64              		.loc 1 25 0
  65 0058 00319FE5 		ldr	r3, .L23
  66 005c 0010D3E5 		ldrb	r1, [r3, #0]	@ zero_extendqisi2
  67              	.LVL4:
  68 0060 011081E2 		add	r1, r1, #1
  69 0064 0010C3E5 		strb	r1, [r3, #0]
  26:main.c        ****         radio_data->byte = 0x42;
  70              		.loc 1 26 0
  71 0068 4230A0E3 		mov	r3, #66
  72 006c 0030C2E5 		strb	r3, [r2, #0]
  73              	.LVL5:
  74              	.L22:
  27:main.c        ****         return TRUE;
  75              		.loc 1 27 0
  76 0070 0100A0E3 		mov	r0, #1
  77 0074 370000EA 		b	.L2
  78              	.LVL6:
  79              	.L4:
  28:main.c        ****       }
  29:main.c        ****       break;
  30:main.c        ****     case ROP_READ_32:
  31:main.c        ****       if (address == 2) {
  80              		.loc 1 31 0
  81 0078 020051E3 		cmp	r1, #2
  82 007c 3400001A 		bne	.L21
  32:main.c        ****         radio_data->dword = datavar;
  83              		.loc 1 32 0
  84 0080 D8309FE5 		ldr	r3, .L23
  85 0084 043093E5 		ldr	r3, [r3, #4]
  86 0088 003082E5 		str	r3, [r2, #0]
  87 008c F7FFFFEA 		b	.L22
  88              	.L5:
  33:main.c        ****         return TRUE;
  34:main.c        ****       }
  35:main.c        ****       break;
  36:main.c        ****     case ROP_READ_MB:
  37:main.c        ****       if (address == 2) {
  89              		.loc 1 37 0
  90 0090 020051E3 		cmp	r1, #2
  91 0094 2E00001A 		bne	.L21
  38:main.c        ****         radio_data->multibyte.size = last_mb_size;
  92              		.loc 1 38 0
  93 0098 C0009FE5 		ldr	r0, .L23
  94              	.LVL7:
  95 009c 0810D0E5 		ldrb	r1, [r0, #8]	@ zero_extendqisi2
  96              	.LVL8:
  39:main.c        ****         for (i = 0; i < last_mb_size; i++) {
  97              		.loc 1 39 0
  98 00a0 0030A0E3 		mov	r3, #0
  38:main.c        ****         radio_data->multibyte.size = last_mb_size;
  99              		.loc 1 38 0
 100 00a4 0010C2E5 		strb	r1, [r2, #0]
 101              	.LVL9:
  40:main.c        ****           radio_data->multibyte.data[i] = mb_buffer[i];
 102              		.loc 1 40 0
 103 00a8 090080E2 		add	r0, r0, #9
  39:main.c        ****         for (i = 0; i < last_mb_size; i++) {
 104              		.loc 1 39 0
 105 00ac 030000EA 		b	.L11
 106              	.LVL10:
 107              	.L12:
 108              		.loc 1 40 0 discriminator 2
 109 00b0 0040D3E7 		ldrb	r4, [r3, r0]	@ zero_extendqisi2
  13:main.c        **** static int8_t register_handler(uint8_t operation, uint8_t address, RadioData* radio_data)
 110              		.loc 1 13 0 discriminator 2
 111 00b4 03C082E0 		add	ip, r2, r3
 112              		.loc 1 40 0 discriminator 2
 113 00b8 0140CCE5 		strb	r4, [ip, #1]
 114 00bc 013083E2 		add	r3, r3, #1
 115              	.L11:
  39:main.c        ****         for (i = 0; i < last_mb_size; i++) {
 116              		.loc 1 39 0 discriminator 1
 117 00c0 FFC003E2 		and	ip, r3, #255
 118 00c4 01005CE1 		cmp	ip, r1
 119 00c8 F8FFFF3A 		bcc	.L12
 120 00cc E7FFFFEA 		b	.L22
 121              	.LVL11:
 122              	.L6:
  41:main.c        ****         }
  42:main.c        ****         return TRUE;
  43:main.c        ****       }
  44:main.c        ****       break;
  45:main.c        ****     case ROP_WRITE_8:
  46:main.c        ****       if (address >= 2 && address <= 4) {
 123              		.loc 1 46 0
 124 00d0 023041E2 		sub	r3, r1, #2
 125 00d4 020053E3 		cmp	r3, #2
  47:main.c        ****         mb_buffer[address - 2] = radio_data->byte;
 126              		.loc 1 47 0
 127 00d8 0030D295 		ldrlsb	r3, [r2, #0]	@ zero_extendqisi2
 128 00dc 7C209F95 		ldrls	r2, .L23
 129              	.LVL12:
 130 00e0 01108290 		addls	r1, r2, r1
 131              	.LVL13:
 132 00e4 0730C195 		strlsb	r3, [r1, #7]
 133 00e8 E0FFFF9A 		bls	.L22
 134              	.LVL14:
 135              	.L7:
  48:main.c        ****         return TRUE;
  49:main.c        ****       }
  50:main.c        ****     case ROP_WRITE_16:
  51:main.c        ****       if (address == 7) {
 136              		.loc 1 51 0
 137 00ec 070051E3 		cmp	r1, #7
 138 00f0 1700001A 		bne	.L21
  52:main.c        ****         datavar = (datavar * 3) + radio_data->word;
 139              		.loc 1 52 0
 140 00f4 64309FE5 		ldr	r3, .L23
 141 00f8 B010D2E1 		ldrh	r1, [r2, #0]
 142              	.LVL15:
 143 00fc 042093E5 		ldr	r2, [r3, #4]
 144              	.LVL16:
 145 0100 822082E0 		add	r2, r2, r2, asl #1
 146 0104 022081E0 		add	r2, r1, r2
 147 0108 042083E5 		str	r2, [r3, #4]
 148 010c D7FFFFEA 		b	.L22
 149              	.LVL17:
 150              	.L8:
  53:main.c        ****         return TRUE;
  54:main.c        ****       }
  55:main.c        ****       break;
  56:main.c        ****     case ROP_WRITE_MB:
  57:main.c        ****       if (address == 2) {
 151              		.loc 1 57 0
 152 0110 020051E3 		cmp	r1, #2
 153 0114 0E00001A 		bne	.L21
  58:main.c        ****         last_mb_size = radio_data->multibyte.size;
 154              		.loc 1 58 0
 155 0118 40009FE5 		ldr	r0, .L23
 156              	.LVL18:
 157 011c 0010D2E5 		ldrb	r1, [r2, #0]	@ zero_extendqisi2
 158              	.LVL19:
  59:main.c        ****         for (i = 0; i < last_mb_size; i++) {
 159              		.loc 1 59 0
 160 0120 0030A0E3 		mov	r3, #0
  58:main.c        ****         last_mb_size = radio_data->multibyte.size;
 161              		.loc 1 58 0
 162 0124 0810C0E5 		strb	r1, [r0, #8]
 163              	.LVL20:
  60:main.c        ****           mb_buffer[i] = radio_data->multibyte.data[i] + 4;
 164              		.loc 1 60 0
 165 0128 090080E2 		add	r0, r0, #9
  59:main.c        ****         for (i = 0; i < last_mb_size; i++) {
 166              		.loc 1 59 0
 167 012c 040000EA 		b	.L13
 168              	.LVL21:
 169              	.L14:
  13:main.c        **** static int8_t register_handler(uint8_t operation, uint8_t address, RadioData* radio_data)
 170              		.loc 1 13 0 discriminator 2
 171 0130 03C082E0 		add	ip, r2, r3
 172              		.loc 1 60 0 discriminator 2
 173 0134 01C0DCE5 		ldrb	ip, [ip, #1]	@ zero_extendqisi2
 174 0138 04C08CE2 		add	ip, ip, #4
 175 013c 00C0C3E7 		strb	ip, [r3, r0]
 176 0140 013083E2 		add	r3, r3, #1
 177              	.L13:
  59:main.c        ****         for (i = 0; i < last_mb_size; i++) {
 178              		.loc 1 59 0 discriminator 1
 179 0144 FFC003E2 		and	ip, r3, #255
 180 0148 01005CE1 		cmp	ip, r1
 181 014c F7FFFF3A 		bcc	.L14
 182 0150 C6FFFFEA 		b	.L22
 183              	.LVL22:
 184              	.L21:
  61:main.c        ****         }
  62:main.c        ****         return TRUE;
  63:main.c        ****       }
  64:main.c        ****       break;
  65:main.c        ****   }
  66:main.c        ****   return FALSE;
 185              		.loc 1 66 0
 186 0154 0000A0E3 		mov	r0, #0
 187              	.LVL23:
 188              	.L2:
  67:main.c        **** }
 189              		.loc 1 67 0
 190 0158 1000BDE8 		ldmfd	sp!, {r4}
 191 015c 1EFF2FE1 		bx	lr
 192              	.L24:
 193              		.align	2
 194              	.L23:
 195 0160 00000000 		.word	.LANCHOR0
 196              		.cfi_endproc
 197              	.LFE0:
 199              		.section	.text.startup,"ax",%progbits
 200              		.align	2
 201              		.global	main
 203              	main:
 204              	.LFB1:
  68:main.c        **** 
  69:main.c        **** int main(void)
  70:main.c        **** {
 205              		.loc 1 70 0
 206              		.cfi_startproc
 207              		@ Function supports interworking.
 208              		@ Volatile: function does not return.
 209              		@ args = 0, pretend = 0, frame = 0
 210              		@ frame_needed = 0, uses_anonymous_args = 0
 211 0000 08402DE9 		stmfd	sp!, {r3, lr}
 212              	.LCFI1:
 213              		.cfi_def_cfa_offset 8
 214              		.cfi_offset 3, -8
 215              		.cfi_offset 14, -4
  71:main.c        ****   hardware_init();
 216              		.loc 1 71 0
 217 0004 FEFFFFEB 		bl	hardware_init
 218              	.LVL24:
  72:main.c        ****   
  73:main.c        ****   // Registers the register handler callback function
  74:main.c        ****   radio_add_reg_callback(register_handler);
 219              		.loc 1 74 0
 220 0008 4C009FE5 		ldr	r0, .L27
 221 000c FEFFFFEB 		bl	radio_add_reg_callback
 222              	.LVL25:
  75:main.c        ****   
  76:main.c        ****   // Changes the color of the led (first red then green) to show the boot
  77:main.c        ****   // and then say that the module is ready.
  78:main.c        ****   set_color_i(4, 0);
 223              		.loc 1 78 0
 224 0010 0010A0E3 		mov	r1, #0
 225 0014 0400A0E3 		mov	r0, #4
 226 0018 FEFFFFEB 		bl	set_color_i
 227              	.LVL26:
  79:main.c        ****   pause(ONE_SEC);
 228              		.loc 1 79 0
 229 001c 3C009FE5 		ldr	r0, .L27+4
 230 0020 FEFFFFEB 		bl	pause
 231              	.LVL27:
  80:main.c        ****   set_color_i(2, 0);
 232              		.loc 1 80 0
 233 0024 0200A0E3 		mov	r0, #2
 234 0028 0010A0E3 		mov	r1, #0
 235 002c FEFFFFEB 		bl	set_color_i
 236              	.LVL28:
 237              	.L26:
  81:main.c        ****   
  82:main.c        ****   // Keeps the LED blinking in green to demonstrate that the main program is
  83:main.c        ****   // still running and registers are processed in background.
  84:main.c        ****   while (1) {
  85:main.c        ****     set_color_i(2, 0);
 238              		.loc 1 85 0 discriminator 1
 239 0030 0010A0E3 		mov	r1, #0
 240 0034 0200A0E3 		mov	r0, #2
 241 0038 FEFFFFEB 		bl	set_color_i
 242              	.LVL29:
  86:main.c        ****     pause(ONE_SEC / 2);
 243              		.loc 1 86 0 discriminator 1
 244 003c 20009FE5 		ldr	r0, .L27+8
 245 0040 FEFFFFEB 		bl	pause
 246              	.LVL30:
  87:main.c        ****     set_color_i(0, 0);
 247              		.loc 1 87 0 discriminator 1
 248 0044 0000A0E3 		mov	r0, #0
 249 0048 0010A0E1 		mov	r1, r0
 250 004c FEFFFFEB 		bl	set_color_i
 251              	.LVL31:
  88:main.c        ****     pause(ONE_SEC / 2);
 252              		.loc 1 88 0 discriminator 1
 253 0050 0C009FE5 		ldr	r0, .L27+8
 254 0054 FEFFFFEB 		bl	pause
 255              	.LVL32:
 256 0058 F4FFFFEA 		b	.L26
 257              	.L28:
 258              		.align	2
 259              	.L27:
 260 005c 00000000 		.word	register_handler
 261 0060 80969800 		.word	10000000
 262 0064 404B4C00 		.word	5000000
 263              		.cfi_endproc
 264              	.LFE1:
 266              		.bss
 267              		.align	2
 268              		.set	.LANCHOR0,. + 0
 271              	counter:
 272 0000 00       		.space	1
 273 0001 000000   		.space	3
 276              	datavar:
 277 0004 00000000 		.space	4
 280              	last_mb_size:
 281 0008 00       		.space	1
 284              	mb_buffer:
 285 0009 00000000 		.space	29
 285      00000000 
 285      00000000 
 285      00000000 
 285      00000000 
 286 0026 0000     		.text
 287              	.Letext0:
 288              		.file 2 "c:/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 289              		.file 3 "../firmware/radio.h"
 290              		.file 4 "../firmware/hardware.h"
 291              		.file 5 "../firmware/sysTime.h"
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:16     .text:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:18     .text:00000000 register_handler
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:37     .text:00000010 $d
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:47     .text:00000030 $a
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:195    .text:00000160 $d
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:200    .text.startup:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:203    .text.startup:00000000 main
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:260    .text.startup:0000005c $d
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:267    .bss:00000000 $d
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:271    .bss:00000000 counter
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:276    .bss:00000004 datavar
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:280    .bss:00000008 last_mb_size
C:\Users\ncmorand\AppData\Local\Temp\ccAGdL9Z.s:284    .bss:00000009 mb_buffer
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
hardware_init
radio_add_reg_callback
set_color_i
pause
