   1              		.cpu arm7tdmi-s
   2              		.fpu softvfp
   3              		.eabi_attribute 20, 1
   4              		.eabi_attribute 21, 1
   5              		.eabi_attribute 23, 3
   6              		.eabi_attribute 24, 1
   7              		.eabi_attribute 25, 1
   8              		.eabi_attribute 26, 1
   9              		.eabi_attribute 30, 4
  10              		.eabi_attribute 34, 0
  11              		.eabi_attribute 18, 4
  12              		.file	"uartISR.c"
  13              		.text
  14              	.Ltext0:
  15              		.cfi_sections	.debug_frame
  16              		.align	2
  17              		.global	uart0ISR
  19              	uart0ISR:
  20              	.LFB2:
  21              		.file 1 "../firmware/uartISR.c"
   1:../firmware/uartISR.c **** #include "LPC21xx.h"
   2:../firmware/uartISR.c **** #include "uart.h"
   3:../firmware/uartISR.c **** #include "uartISR.h"
   4:../firmware/uartISR.c **** #include "armVIC.h"
   5:../firmware/uartISR.c **** #include "radio.h"
   6:../firmware/uartISR.c **** 
   7:../firmware/uartISR.c **** void init_uart0_isr()
   8:../firmware/uartISR.c **** {
   9:../firmware/uartISR.c ****   VICIntSelect &= ~VIC_BIT(VIC_UART0);    // UART0 selected as IRQ
  10:../firmware/uartISR.c ****   VICIntEnable = VIC_BIT(VIC_UART0);      // UART0 interrupt enabled
  11:../firmware/uartISR.c ****   VICVectCntl0 = VIC_ENABLE | VIC_UART0;  // UART0 is IRQ0
  12:../firmware/uartISR.c ****   VICVectAddr0 = (uint32_t) uart0ISR;
  13:../firmware/uartISR.c ****   U0IER = UIER_ERBFI;                     // enable receiver interrupts
  14:../firmware/uartISR.c **** }
  15:../firmware/uartISR.c **** 
  16:../firmware/uartISR.c **** uint8_t uart0_waitch()
  17:../firmware/uartISR.c **** {
  18:../firmware/uartISR.c ****   while (!(U0LSR & ULSR_RDR));
  19:../firmware/uartISR.c ****   return U0RBR;
  20:../firmware/uartISR.c **** }
  21:../firmware/uartISR.c **** 
  22:../firmware/uartISR.c **** void uart0ISR(void)
  23:../firmware/uartISR.c **** {
  22              		.loc 1 23 0
  23              		.cfi_startproc
  24              		@ Function supports interworking.
  25              		@ Naked Function: prologue and epilogue provided by programmer.
  26              		@ args = 0, pretend = 0, frame = 0
  27              		@ frame_needed = 0, uses_anonymous_args = 0
  24:../firmware/uartISR.c ****   uint8_t iid;
  25:../firmware/uartISR.c **** 
  26:../firmware/uartISR.c ****   // perform proper ISR entry so thumb-interwork works properly
  27:../firmware/uartISR.c ****   ISR_ENTRY();
  28              		.loc 1 27 0
  29              	@ 27 "../firmware/uartISR.c" 1
  30 0000 04E04EE2 		 sub   lr, lr,#4
  31 0004 FF5F2DE9 	 stmfd sp!,{r0-r12,lr}
  32 0008 00104FE1 	 mrs   r1, spsr
  33 000c 02002DE9 	 stmfd sp!,{r1}
  34              	@ 0 "" 2
  28:../firmware/uartISR.c **** 
  29:../firmware/uartISR.c ****   // loop until not more interrupt sources
  30:../firmware/uartISR.c ****   while (((iid = U0IIR) & UIIR_NO_INT) == 0)
  35              		.loc 1 30 0
  36 0010 64409FE5 		ldr	r4, .L18
  37 0014 0F0000EA 		b	.L16
  38              	.L7:
  31:../firmware/uartISR.c ****   {
  32:../firmware/uartISR.c ****     // identify & process the highest priority interrupt
  33:../firmware/uartISR.c ****     switch (iid & UIIR_ID_MASK)
  39              		.loc 1 33 0
  40 0018 0E3003E2 		and	r3, r3, #14
  41 001c 060053E3 		cmp	r3, #6
  34:../firmware/uartISR.c ****     {
  35:../firmware/uartISR.c ****     case UIIR_RLS_INT:                // Receive Line Status
  36:../firmware/uartISR.c ****       U0LSR;                          // read LSR to clear
  42              		.loc 1 36 0
  43 0020 1430D405 		ldreqb	r3, [r4, #20]	@ zero_extendqisi2
  33:../firmware/uartISR.c ****     switch (iid & UIIR_ID_MASK)
  44              		.loc 1 33 0
  45 0024 0B00000A 		beq	.L16
  46 0028 0C0053E3 		cmp	r3, #12
  47 002c 0400000A 		beq	.L12
  48 0030 040053E3 		cmp	r3, #4
  37:../firmware/uartISR.c ****       break;
  38:../firmware/uartISR.c **** 
  39:../firmware/uartISR.c ****     case UIIR_CTI_INT:                // Character Timeout Indicator
  40:../firmware/uartISR.c ****     case UIIR_RDA_INT:                // Receive Data Available
  41:../firmware/uartISR.c ****       do {
  42:../firmware/uartISR.c ****         process_UART_in();
  43:../firmware/uartISR.c ****       } while (U0LSR & ULSR_RDR);
  44:../firmware/uartISR.c ****       break;
  45:../firmware/uartISR.c **** 
  46:../firmware/uartISR.c ****     default:                          // Unknown
  47:../firmware/uartISR.c ****       U0LSR;
  49              		.loc 1 47 0
  50 0034 1430D415 		ldrneb	r3, [r4, #20]	@ zero_extendqisi2
  48:../firmware/uartISR.c ****       U0RBR;
  51              		.loc 1 48 0
  52 0038 0030D415 		ldrneb	r3, [r4, #0]	@ zero_extendqisi2
  33:../firmware/uartISR.c ****     switch (iid & UIIR_ID_MASK)
  53              		.loc 1 33 0
  54 003c 0500001A 		bne	.L16
  55 0040 FFFFFFEA 		b	.L12
  56              	.L12:
  42:../firmware/uartISR.c ****         process_UART_in();
  57              		.loc 1 42 0 discriminator 1
  58 0044 FEFFFFEB 		bl	process_UART_in
  59              	.LVL0:
  43:../firmware/uartISR.c ****       } while (U0LSR & ULSR_RDR);
  60              		.loc 1 43 0 discriminator 1
  61 0048 1430D4E5 		ldrb	r3, [r4, #20]	@ zero_extendqisi2
  62 004c 010013E3 		tst	r3, #1
  63 0050 FBFFFF1A 		bne	.L12
  64 0054 FFFFFFEA 		b	.L16
  65              	.L16:
  30:../firmware/uartISR.c ****   while (((iid = U0IIR) & UIIR_NO_INT) == 0)
  66              		.loc 1 30 0 discriminator 1
  67 0058 0830D4E5 		ldrb	r3, [r4, #8]	@ zero_extendqisi2
  68 005c 010013E3 		tst	r3, #1
  69 0060 ECFFFF0A 		beq	.L7
  49:../firmware/uartISR.c ****       break;
  50:../firmware/uartISR.c ****     }
  51:../firmware/uartISR.c ****   }
  52:../firmware/uartISR.c **** 
  53:../firmware/uartISR.c ****   VICVectAddr = 0x00000000;             // clear this interrupt from the VIC
  70              		.loc 1 53 0
  71 0064 0020A0E3 		mov	r2, #0
  72 0068 0030E0E3 		mvn	r3, #0
  73 006c CF2F03E5 		str	r2, [r3, #-4047]
  54:../firmware/uartISR.c ****   ISR_EXIT();                           // recover registers and return
  74              		.loc 1 54 0
  75              	@ 54 "../firmware/uartISR.c" 1
  76 0070 0200BDE8 		 ldmfd sp!,{r1}
  77 0074 01F061E1 	 msr   spsr_c,r1
  78 0078 FF9FFDE8 	 ldmfd sp!,{r0-r12,pc}^
  79              	@ 0 "" 2
  55:../firmware/uartISR.c **** }
  80              		.loc 1 55 0
  81              	.L19:
  82              		.align	2
  83              	.L18:
  84 007c 00C000E0 		.word	-536821760
  85              		.cfi_endproc
  86              	.LFE2:
  88              		.align	2
  89              		.global	init_uart0_isr
  91              	init_uart0_isr:
  92              	.LFB0:
   8:../firmware/uartISR.c **** {
  93              		.loc 1 8 0
  94              		.cfi_startproc
  95              		@ Function supports interworking.
  96              		@ args = 0, pretend = 0, frame = 0
  97              		@ frame_needed = 0, uses_anonymous_args = 0
  98              		@ link register save eliminated.
   9:../firmware/uartISR.c ****   VICIntSelect &= ~VIC_BIT(VIC_UART0);    // UART0 selected as IRQ
  99              		.loc 1 9 0
 100 0080 0030E0E3 		mvn	r3, #0
 101 0084 F32F13E5 		ldr	r2, [r3, #-4083]
 102 0088 4020C2E3 		bic	r2, r2, #64
 103 008c F32F03E5 		str	r2, [r3, #-4083]
  10:../firmware/uartISR.c ****   VICIntEnable = VIC_BIT(VIC_UART0);      // UART0 interrupt enabled
 104              		.loc 1 10 0
 105 0090 4020A0E3 		mov	r2, #64
 106 0094 EF2F03E5 		str	r2, [r3, #-4079]
  11:../firmware/uartISR.c ****   VICVectCntl0 = VIC_ENABLE | VIC_UART0;  // UART0 is IRQ0
 107              		.loc 1 11 0
 108 0098 2620A0E3 		mov	r2, #38
 109 009c FF2D03E5 		str	r2, [r3, #-3583]
  12:../firmware/uartISR.c ****   VICVectAddr0 = (uint32_t) uart0ISR;
 110              		.loc 1 12 0
 111 00a0 10209FE5 		ldr	r2, .L21
 112 00a4 FF2E03E5 		str	r2, [r3, #-3839]
  13:../firmware/uartISR.c ****   U0IER = UIER_ERBFI;                     // enable receiver interrupts
 113              		.loc 1 13 0
 114 00a8 0C309FE5 		ldr	r3, .L21+4
 115 00ac 0120A0E3 		mov	r2, #1
 116 00b0 0420C3E5 		strb	r2, [r3, #4]
 117 00b4 1EFF2FE1 		bx	lr
 118              	.L22:
 119              		.align	2
 120              	.L21:
 121 00b8 00000000 		.word	uart0ISR
 122 00bc 00C000E0 		.word	-536821760
 123              		.cfi_endproc
 124              	.LFE0:
 126              		.align	2
 127              		.global	uart0_waitch
 129              	uart0_waitch:
 130              	.LFB1:
  17:../firmware/uartISR.c **** {
 131              		.loc 1 17 0
 132              		.cfi_startproc
 133              		@ Function supports interworking.
 134              		@ args = 0, pretend = 0, frame = 0
 135              		@ frame_needed = 0, uses_anonymous_args = 0
 136              		@ link register save eliminated.
  18:../firmware/uartISR.c ****   while (!(U0LSR & ULSR_RDR));
 137              		.loc 1 18 0
 138 00c0 14209FE5 		ldr	r2, .L29
 139              	.L24:
  18:../firmware/uartISR.c ****   while (!(U0LSR & ULSR_RDR));
 140              		.loc 1 18 0 is_stmt 0 discriminator 1
 141 00c4 1430D2E5 		ldrb	r3, [r2, #20]	@ zero_extendqisi2
 142 00c8 010013E3 		tst	r3, #1
 143 00cc FCFFFF0A 		beq	.L24
  19:../firmware/uartISR.c ****   return U0RBR;
 144              		.loc 1 19 0 is_stmt 1
 145 00d0 04309FE5 		ldr	r3, .L29
 146 00d4 0000D3E5 		ldrb	r0, [r3, #0]	@ zero_extendqisi2
  20:../firmware/uartISR.c **** }
 147              		.loc 1 20 0
 148 00d8 1EFF2FE1 		bx	lr
 149              	.L30:
 150              		.align	2
 151              	.L29:
 152 00dc 00C000E0 		.word	-536821760
 153              		.cfi_endproc
 154              	.LFE1:
 156              	.Letext0:
 157              		.file 2 "../firmware/lpcUART.h"
 158              		.file 3 "../firmware/lpcVIC.h"
 159              		.file 4 "c:/yagarto/lib/gcc/../../arm-none-eabi/sys-include/stdint.h"
 160              		.file 5 "../firmware/radio.h"
DEFINED SYMBOLS
                            *ABS*:00000000 uartISR.c
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:16     .text:00000000 $a
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:19     .text:00000000 uart0ISR
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:84     .text:0000007c $d
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:88     .text:00000080 $a
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:91     .text:00000080 init_uart0_isr
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:121    .text:000000b8 $d
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:126    .text:000000c0 $a
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:129    .text:000000c0 uart0_waitch
C:\Users\ncmorand\AppData\Local\Temp\ccOt6FO9.s:152    .text:000000dc $d
                     .debug_frame:00000010 $d

UNDEFINED SYMBOLS
process_UART_in
